import { s as selectStorePrompt, r as reloadStoreListPrompt, a as fetchAllStores, f as fetchAppExtensionRegistrations, b as selectOrCreateApp, c as fetchAppFromApiKey, d as fetchOrgAndApps, e as fetchOrganizations, g as selectOrganizationPrompt, h as fetchOrgFromId, i as reuseDevConfigPrompt } from './select-app-bae6a630.js';
import { output, system, error, ui, environment, api, session, store } from '@shopify/cli-kit';
import { k as extensionGraphqlId, m as getAppIdentifiers, d as updateAppIdentifiers } from './app-5df50971.js';

const ConvertToDevError = (storeName, message) => {
  return new error.Bug(`Error converting store ${storeName} to a Test store: ${message}`, "This store might not be compatible with draft apps, please try a different store");
};
const StoreNotFoundError = (storeName, org) => {
  return new error.Bug(`Could not find ${storeName} in the Organization ${org.businessName} as a valid development store.`, `Visit https://partners.shopify.com/${org.id}/stores to create a new store in your organization`);
};
const InvalidStore = (storeName) => {
  return new error.Bug(`${storeName} can't be used to test draft apps`, "Please try with a different store.");
};
const CreateStoreLink = (orgId) => {
  const url = `https://partners.shopify.com/${orgId}/stores/new?store_type=dev_store`;
  return `Looks like you don't have a dev store in the Partners org you selected. Keep going \u2014 create a dev store on Shopify Partners:
${url}
`;
};
async function selectStore(stores, org, token, cachedStoreName) {
  if (cachedStoreName) {
    await convertToTestStoreIfNeeded(cachedStoreName, stores, org, token);
    return cachedStoreName;
  }
  const store = await selectStorePrompt(stores);
  if (store) {
    await convertToTestStoreIfNeeded(store.shopDomain, stores, org, token);
    return store.shopDomain;
  }
  output.info(`
${CreateStoreLink(org.id)}`);
  await system.sleep(5);
  const reload = await reloadStoreListPrompt(org);
  if (!reload) {
    throw new error.CancelExecution();
  }
  const data = await waitForCreatedStore(org.id, token);
  return selectStore(data, org, token);
}
async function waitForCreatedStore(orgId, token) {
  const retries = 10;
  const secondsToWait = 3;
  let data = [];
  const list = new ui.Listr([
    {
      title: "Fetching organization data",
      task: async () => {
        for (let i = 0; i < retries; i++) {
          const stores = await fetchAllStores(orgId, token);
          if (stores.length > 0) {
            data = stores;
            return;
          }
          await system.sleep(secondsToWait);
        }
      }
    }
  ], { rendererSilent: environment.local.isUnitTest() });
  await list.run();
  return data;
}
async function convertToTestStoreIfNeeded(storeDomain, stores, org, token) {
  const store = stores.find((store2) => store2.shopDomain === storeDomain);
  if (!store)
    throw StoreNotFoundError(storeDomain, org);
  if (!store.transferDisabled && !store.convertableToPartnerTest)
    throw InvalidStore(store.shopDomain);
  if (!store.transferDisabled)
    await convertStoreToTest(store, org.id, token);
}
async function convertStoreToTest(store, orgId, token) {
  const query = api.graphql.ConvertDevToTestStoreQuery;
  const variables = {
    input: {
      organizationID: parseInt(orgId, 10),
      shopId: store.shopId
    }
  };
  const result = await api.partners.request(query, token, variables);
  if (!result.convertDevToTestStore.convertedToTestStore) {
    const errors = result.convertDevToTestStore.userErrors.map((error2) => error2.message).join(", ");
    throw ConvertToDevError(store.shopDomain, errors);
  }
  output.success(`Converted ${store.shopDomain} to a Test store`);
}

async function automaticMatchmaking(localExtensions, remoteRegistrations, identifiers) {
  if (remoteRegistrations.length > localExtensions.length) {
    return { result: "invalid-environment" };
  }
  const validIdentifiers = identifiers;
  const localId = (extension) => validIdentifiers[extension.localIdentifier];
  const localUUIDs = () => Object.values(validIdentifiers);
  const existsRemotely = (extension) => {
    const remote = remoteRegistrations.find((registration) => registration.uuid === localId(extension));
    return remote !== void 0 && remote.type === extension.graphQLType;
  };
  const pendingLocal = localExtensions.filter((extension) => !existsRemotely(extension));
  const pendingRemote = remoteRegistrations.filter((registration) => !localUUIDs().includes(registration.uuid));
  const remoteNeedsManualMatch = (() => {
    const types = pendingRemote.map((ext) => ext.type).filter((type, i, array) => array.indexOf(type) !== i);
    return pendingRemote.filter((ext) => types.includes(ext.type));
  })();
  const localNeedsManualMatch = (() => {
    const types = pendingLocal.map((ext) => ext.graphQLType).filter((type, i, array) => array.indexOf(type) !== i);
    const manualTypes = types.filter((type) => remoteNeedsManualMatch.some((reg) => reg.type === type));
    return pendingLocal.filter((ext) => manualTypes.includes(ext.graphQLType));
  })();
  const newLocalPending = pendingLocal.filter((extension) => !localNeedsManualMatch.includes(extension));
  const newRemotePending = pendingRemote.filter((registration) => !remoteNeedsManualMatch.includes(registration));
  const impossible = newRemotePending.filter((reg) => !newLocalPending.map((ext) => ext.graphQLType).includes(reg.type));
  if (impossible.length > 0 || newRemotePending.length > newLocalPending.length) {
    return { result: "invalid-environment" };
  }
  if (newRemotePending.length > newLocalPending.length) {
    return { result: "invalid-environment" };
  }
  const extensionsToCreate = [];
  const pendingConfirmation = [];
  newLocalPending.forEach((extension) => {
    const possibleMatches = newRemotePending.filter((req) => req.type === extension.graphQLType);
    if (possibleMatches.length === 0) {
      extensionsToCreate.push(extension);
    } else if (possibleMatches[0].title.toLowerCase() === extension.localIdentifier.toLowerCase()) {
      validIdentifiers[extension.localIdentifier] = possibleMatches[0].uuid;
    } else {
      pendingConfirmation.push({ extension, registration: possibleMatches[0] });
    }
  });
  return {
    result: "ok",
    identifiers: validIdentifiers,
    pendingConfirmation,
    toCreate: extensionsToCreate,
    toManualMatch: { local: localNeedsManualMatch, remote: remoteNeedsManualMatch }
  };
}

async function manualMatchIds(localExtensions, remoteExtensions) {
  const identifiers = {};
  let pendingRemote = remoteExtensions;
  let pendingLocal = localExtensions;
  for (const extension of localExtensions) {
    const registrationsForType = pendingRemote.filter((reg) => reg.type === extension.graphQLType);
    if (registrationsForType.length === 0)
      continue;
    const selected = await selectRegistrationPrompt(extension, registrationsForType);
    if (!selected)
      continue;
    identifiers[extension.localIdentifier] = selected.uuid;
    pendingRemote = pendingRemote.filter((reg) => reg.uuid !== selected.uuid);
    pendingLocal = pendingLocal.filter((reg) => reg.localIdentifier !== extension.localIdentifier);
  }
  if (pendingRemote.length > 0)
    return { result: "pending-remote" };
  return { result: "ok", identifiers, toCreate: pendingLocal };
}
async function selectRegistrationPrompt(extension, registrations) {
  const registrationList = registrations.map((reg) => ({
    name: `Match it to ${reg.title} (ID: ${reg.id} on Shopify Partners)`,
    value: reg.uuid
  }));
  registrationList.push({ name: "Create new extension", value: "create" });
  const choice = await ui.prompt([
    {
      type: "autocomplete",
      name: "uuid",
      message: `How would you like to deploy your "${extension.localIdentifier}"?`,
      choices: registrationList
    }
  ]);
  return registrations.find((reg) => reg.uuid === choice.uuid);
}

async function createExtension(apiKey, type, name, token) {
  const query = api.graphql.ExtensionCreateQuery;
  const variables = {
    apiKey,
    type: extensionGraphqlId(type),
    title: name,
    config: JSON.stringify({}),
    context: null
  };
  const result = await api.partners.request(query, token, variables);
  if (result.extensionCreate.userErrors?.length > 0) {
    const errors = result.extensionCreate.userErrors.map((error2) => error2.message).join(", ");
    throw new error.Abort(errors);
  }
  return result.extensionCreate.extensionRegistration;
}

const DeployError = (appName, packageManager) => {
  return new error.Abort(`Deployment failed because this local project doesn't seem to match the app "${appName}" in Shopify Partners.`, `\u2022 If you didn't intend to select this app, run ${output.content`${output.token.packagejsonScript(packageManager, "deploy", "--reset")}`.value}
\u2022 If this is the app you intended, check your local project and make sure
  it contains the same number and types of extensions as the Shopify app
  you've selected. You may need to scaffold missing extensions.`);
};
async function ensureDeploymentIdsPresence(options) {
  const remoteSpecifications = await fetchAppExtensionRegistrations({ token: options.token, apiKey: options.appId });
  const remoteRegistrations = remoteSpecifications.app.extensionRegistrations;
  const validIdentifiers = options.envIdentifiers.extensions ?? {};
  const functionLocalIdentifiers = Object.fromEntries(options.app.extensions.function.map((extension) => extension.localIdentifier).map((extensionIdentifier) => {
    return validIdentifiers[extensionIdentifier] ? [extensionIdentifier, validIdentifiers[extensionIdentifier]] : void 0;
  }).filter((entry) => entry !== void 0));
  const localExtensions = [...options.app.extensions.ui, ...options.app.extensions.theme];
  const GenericError = () => DeployError(options.appName, options.app.dependencyManager);
  if (localExtensions.length === 0) {
    return {
      app: options.appId,
      extensions: { ...functionLocalIdentifiers },
      extensionIds: {}
    };
  }
  if (remoteRegistrations.length > localExtensions.length) {
    throw GenericError();
  }
  const match = await automaticMatchmaking(localExtensions, remoteRegistrations, validIdentifiers);
  if (match.result === "invalid-environment") {
    throw GenericError();
  }
  let validMatches = match.identifiers ?? {};
  const validMatchesById = {};
  if (match.pendingConfirmation.length > 0) {
    for (const pending of match.pendingConfirmation) {
      const confirmed = await matchConfirmationPrompt(pending.extension, pending.registration);
      if (!confirmed)
        throw new error.AbortSilent();
      validMatches[pending.extension.localIdentifier] = pending.registration.uuid;
    }
  }
  const extensionsToCreate = match.toCreate ?? [];
  if (match.toManualMatch.local.length > 0) {
    const matchResult = await manualMatchIds(match.toManualMatch.local, match.toManualMatch.remote);
    if (matchResult.result === "pending-remote")
      throw GenericError();
    validMatches = { ...validMatches, ...matchResult.identifiers };
    extensionsToCreate.push(...matchResult.toCreate);
  }
  if (extensionsToCreate.length > 0) {
    const newIdentifiers = await createExtensions(extensionsToCreate, options.appId);
    for (const [localIdentifier, registration] of Object.entries(newIdentifiers)) {
      validMatches[localIdentifier] = registration.uuid;
      validMatchesById[localIdentifier] = registration.id;
    }
  }
  for (const [localIdentifier, uuid] of Object.entries(validMatches)) {
    const registration = remoteRegistrations.find((registration2) => registration2.uuid === uuid);
    if (registration)
      validMatchesById[localIdentifier] = registration.id;
  }
  return {
    app: options.appId,
    extensions: { ...validMatches, ...functionLocalIdentifiers },
    extensionIds: validMatchesById
  };
}
async function createExtensions(extensions, appId) {
  const token = await session.ensureAuthenticatedPartners();
  const result = {};
  for (const extension of extensions) {
    const registration = await createExtension(appId, extension.type, extension.localIdentifier, token);
    output.completed(`Created extension ${extension.localIdentifier}.`);
    result[extension.localIdentifier] = registration;
  }
  return result;
}
async function matchConfirmationPrompt(extension, registration) {
  const choices = [
    { name: `Yes, that's right`, value: "yes" },
    { name: `No, cancel deployment`, value: "no" }
  ];
  const choice = await ui.prompt([
    {
      type: "select",
      name: "value",
      message: `Deploy ${extension.localIdentifier} (local name) as ${registration.title} (name on Shopify Partners, ID: ${registration.id})?`,
      choices
    }
  ]);
  return choice.value === "yes";
}

const InvalidApiKeyError = (apiKey) => {
  return new error.Abort(output.content`Invalid API key: ${apiKey}`, output.content`You can find the API key in the app settings in the Partner Dashboard.`);
};
const DeployAppNotFound = (apiKey, dependencyManager) => {
  return new error.Abort(output.content`Couldn't find the app with API key ${apiKey}`, output.content`â€¢ If you didn't intend to select this app, run ${output.content`${output.token.packagejsonScript(dependencyManager, "deploy", "--reset")}`.value}`);
};
async function ensureDevEnvironment(options) {
  const token = await session.ensureAuthenticatedPartners();
  const prodEnvIdentifiers = await getAppIdentifiers({ app: options.app });
  const envExtensionsIds = prodEnvIdentifiers.extensions || {};
  const cachedInfo = getAppDevCachedInfo({
    reset: options.reset,
    directory: options.app.directory,
    apiKey: options.apiKey ?? store.getAppInfo(options.app.directory)?.appId
  });
  const explanation = `
Looks like this is the first time you're running dev for this project.
Configure your preferences by answering a few questions.
`;
  if (cachedInfo === void 0 && !options.reset) {
    output.info(explanation);
  }
  const orgId = cachedInfo?.orgId || await selectOrg(token);
  const { organization, apps, stores } = await fetchOrgsAppsAndStores(orgId, token);
  let { app: selectedApp, store: selectedStore } = await fetchDevDataFromOptions(options, organization, stores, token);
  if (selectedApp && selectedStore) {
    options = await updateDevOptions({ ...options, apiKey: selectedApp.apiKey });
    store.setAppInfo({ appId: selectedApp.apiKey, directory: options.app.directory, storeFqdn: selectedStore, orgId });
    const extensions2 = prodEnvIdentifiers.app === selectedApp.apiKey ? envExtensionsIds : {};
    return {
      app: {
        ...selectedApp,
        apiSecret: selectedApp.apiSecretKeys.length === 0 ? void 0 : selectedApp.apiSecretKeys[0].secret
      },
      storeFqdn: selectedStore,
      identifiers: {
        app: selectedApp.apiKey,
        extensions: extensions2
      }
    };
  }
  selectedApp = selectedApp || await selectOrCreateApp(options.app, apps, organization, token, cachedInfo?.appId);
  store.setAppInfo({ appId: selectedApp.apiKey, title: selectedApp.title, directory: options.app.directory, orgId });
  options = await updateDevOptions({ ...options, apiKey: selectedApp.apiKey });
  selectedStore = selectedStore || await selectStore(stores, organization, token, cachedInfo?.storeFqdn);
  store.setAppInfo({ appId: selectedApp.apiKey, directory: options.app.directory, storeFqdn: selectedStore });
  if (selectedApp.apiKey === cachedInfo?.appId && selectedStore === cachedInfo.storeFqdn) {
    showReusedValues(organization.businessName, options.app, selectedStore);
  }
  const extensions = prodEnvIdentifiers.app === selectedApp.apiKey ? envExtensionsIds : {};
  return {
    app: {
      ...selectedApp,
      apiSecret: selectedApp.apiSecretKeys.length === 0 ? void 0 : selectedApp.apiSecretKeys[0].secret
    },
    storeFqdn: selectedStore,
    identifiers: {
      app: selectedApp.apiKey,
      extensions
    }
  };
}
async function updateDevOptions(options) {
  const updatedApp = await updateAppIdentifiers({
    app: options.app,
    identifiers: {
      app: options.apiKey,
      extensions: {}
    },
    command: "dev"
  });
  return {
    ...options,
    app: updatedApp
  };
}
async function fetchDevAppAndPrompt(app, token) {
  const devAppId = store.getAppInfo(app.directory)?.appId;
  if (!devAppId)
    return void 0;
  const partnersResponse = await fetchAppFromApiKey(devAppId, token);
  if (!partnersResponse)
    return void 0;
  const org = await fetchOrgFromId(partnersResponse.organizationId, token);
  showDevValues(org?.businessName ?? "unknown", partnersResponse.title);
  const reuse = await reuseDevConfigPrompt();
  return reuse ? partnersResponse : void 0;
}
async function ensureDeployEnvironment(options) {
  const token = await session.ensureAuthenticatedPartners();
  let envIdentifiers = await getAppIdentifiers({ app: options.app });
  let partnersApp;
  if (options.reset) {
    envIdentifiers = { app: void 0, extensions: {} };
  } else if (envIdentifiers.app) {
    partnersApp = await fetchAppFromApiKey(envIdentifiers.app, token);
    if (!partnersApp)
      throw DeployAppNotFound(envIdentifiers.app, options.app.dependencyManager);
  } else {
    partnersApp = await fetchDevAppAndPrompt(options.app, token);
  }
  let identifiers = envIdentifiers;
  if (!partnersApp) {
    const result = await fetchOrganizationAndFetchOrCreateApp(options.app, token);
    partnersApp = result.partnersApp;
  }
  identifiers = await ensureDeploymentIdsPresence({
    app: options.app,
    appId: partnersApp.apiKey,
    appName: partnersApp.title,
    token,
    envIdentifiers
  });
  options = {
    ...options,
    app: await updateAppIdentifiers({ app: options.app, identifiers, command: "deploy" })
  };
  return {
    app: options.app,
    partnersApp: {
      id: partnersApp.id,
      title: partnersApp.title,
      appType: partnersApp.appType,
      organizationId: partnersApp.organizationId
    },
    partnersOrganizationId: partnersApp.organizationId,
    identifiers,
    token
  };
}
async function fetchOrganizationAndFetchOrCreateApp(app, token) {
  const orgId = await selectOrg(token);
  const { organization, apps } = await fetchOrgsAppsAndStores(orgId, token);
  const partnersApp = await selectOrCreateApp(app, apps, organization, token, void 0);
  return { orgId, partnersApp };
}
async function fetchOrgsAppsAndStores(orgId, token) {
  let data = {};
  const list = new ui.Listr([
    {
      title: "Fetching organization data",
      task: async () => {
        const organizationAndApps = await fetchOrgAndApps(orgId, token);
        const stores = await fetchAllStores(orgId, token);
        data = { ...organizationAndApps, stores };
      }
    }
  ], { rendererSilent: environment.local.isUnitTest() });
  await list.run();
  return data;
}
async function fetchDevDataFromOptions(options, org, stores, token) {
  let selectedApp;
  let selectedStore;
  if (options.apiKey) {
    selectedApp = await fetchAppFromApiKey(options.apiKey, token);
    if (!selectedApp)
      throw InvalidApiKeyError(options.apiKey);
  }
  if (options.storeFqdn) {
    await convertToTestStoreIfNeeded(options.storeFqdn, stores, org, token);
    selectedStore = options.storeFqdn;
  }
  return { app: selectedApp, store: selectedStore };
}
function getAppDevCachedInfo({
  reset,
  directory,
  apiKey
}) {
  if (!apiKey)
    return void 0;
  if (apiKey && reset)
    store.clearAppInfo(directory);
  return store.getAppInfo(directory);
}
async function selectOrg(token) {
  const orgs = await fetchOrganizations(token);
  const org = await selectOrganizationPrompt(orgs);
  return org.id;
}
function showReusedValues(org, app, store) {
  output.info("\nUsing your previous dev settings:");
  output.info(`Org:        ${org}`);
  output.info(`App:        ${app.name}`);
  output.info(`Dev store:  ${store}
`);
  output.info(output.content`To reset your default dev config, run ${output.token.packagejsonScript(app.dependencyManager, "dev", "--reset")}\n`);
}
function showDevValues(org, appName) {
  output.info("\nYour configs for dev were:");
  output.info(`Org:        ${org}`);
  output.info(`App:        ${appName}
`);
}

export { ensureDevEnvironment as a, ensureDeployEnvironment as e };
//# sourceMappingURL=environment-07360c6a.js.map
