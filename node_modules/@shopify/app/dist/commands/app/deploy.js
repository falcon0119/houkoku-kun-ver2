import { b as getFunctionExtensionPointName, c as blocks, h as hasExtensions, d as updateAppIdentifiers, g as getUIExtensionRendererVersion, i as isUiExtensionType, f as isFunctionExtensionType, j as isThemeExtensionType, a as appFlags, l as load } from '../../app-5df50971.js';
import { b as buildThemeExtensions, a as buildUIExtensions, c as buildFunctionExtension } from '../../extension-3fd19049.js';
import { temporary, path, file, output, api, error, id, http, session, environment, cli } from '@shopify/cli-kit';
import { zip } from '@shopify/cli-kit/node/archiver';
import fs from 'fs';
import { e as ensureDeployEnvironment } from '../../environment-07360c6a.js';
import { f as fetchAppExtensionRegistrations } from '../../select-app-bae6a630.js';
import { Flags, Command } from '@oclif/core';
import '../../cli-925c35a7.js';
import 'node:zlib';
import 'node:fs';
import 'node:stream';
import 'node:util';
import 'url';
import '../../configuration-c24e74ba.js';

async function bundleUIAndBuildFunctionExtensions(options) {
  await temporary.directory(async (tmpDir) => {
    const bundleDirectory = path.join(tmpDir, "bundle");
    await file.mkdir(bundleDirectory);
    await file.touch(path.join(bundleDirectory, ".shopify"));
    await output.concurrent([
      {
        prefix: "theme_extensions",
        action: async (stdout, stderr, signal) => {
          await buildThemeExtensions({
            app: options.app,
            extensions: options.app.extensions.theme,
            stdout,
            stderr,
            signal
          });
        }
      },
      {
        prefix: "extensions",
        action: async (stdout, stderr, signal) => {
          const extensions = options.app.extensions.ui.map((extension) => {
            const extensionId = options.identifiers.extensions[extension.localIdentifier];
            const buildDirectory = path.join(bundleDirectory, extensionId);
            return { ...extension, buildDirectory };
          });
          await buildUIExtensions({
            app: options.app,
            extensions,
            stdout,
            stderr,
            signal
          });
        }
      },
      ...options.app.extensions.function.map((functionExtension) => {
        return {
          prefix: `function_${functionExtension.localIdentifier}`,
          action: async (stdout, stderr, signal) => {
            await buildFunctionExtension(functionExtension, { stdout, stderr, signal, app: options.app });
          }
        };
      })
    ]);
    if (options.bundle) {
      await zip(bundleDirectory, options.bundlePath);
    }
  });
}

async function themeExtensionConfig(themeExtension) {
  const files = {};
  const themeFiles = await path.glob(path.join(themeExtension.directory, "*/*"));
  await Promise.all(themeFiles.map(async (filepath) => {
    const relativePath = path.relative(themeExtension.directory, filepath);
    const dirname = path.dirname(relativePath);
    const encoding = dirname === "assets" ? "binary" : "utf8";
    const fileContents = await file.read(filepath, { encoding });
    files[relativePath] = Buffer.from(fileContents, encoding).toString("base64");
  }));
  return { theme_extension: { files } };
}

async function uploadThemeExtensions(themeExtensions, options) {
  const { apiKey, identifiers, token } = options;
  await Promise.all(themeExtensions.map(async (themeExtension) => {
    const themeExtensionConfig$1 = await themeExtensionConfig(themeExtension);
    const themeId = identifiers.extensionIds[themeExtension.localIdentifier];
    const themeExtensionInput = {
      apiKey,
      config: JSON.stringify(themeExtensionConfig$1),
      context: void 0,
      registrationId: themeId
    };
    const mutation = api.graphql.ExtensionUpdateDraftMutation;
    const result = await api.partners.request(mutation, token, themeExtensionInput);
    if (result.extensionUpdateDraft?.userErrors?.length > 0) {
      const errors = result.extensionUpdateDraft.userErrors.map((error2) => error2.message).join(", ");
      throw new error.Abort(errors);
    }
  }));
}
async function uploadUIExtensionsBundle(options) {
  const deploymentUUID = id.generateRandomUUID();
  const signedURL = await getUIExtensionUploadURL(options.apiKey, deploymentUUID);
  const formData = http.formData();
  const buffer = fs.readFileSync(options.bundlePath);
  formData.append("my_upload", buffer);
  await http.fetch(signedURL, {
    method: "put",
    body: buffer,
    headers: formData.getHeaders()
  });
  const variables = {
    apiKey: options.apiKey,
    uuid: deploymentUUID,
    bundleUrl: signedURL,
    extensions: options.extensions
  };
  const mutation = api.graphql.CreateDeployment;
  const result = await api.partners.request(mutation, options.token, variables);
  if (result.deploymentCreate?.userErrors?.length > 0) {
    const errors = result.deploymentCreate.userErrors.map((error2) => error2.message).join(", ");
    throw new error.Abort(errors);
  }
}
async function getUIExtensionUploadURL(apiKey, deploymentUUID) {
  const mutation = api.graphql.GenerateSignedUploadUrl;
  const token = await session.ensureAuthenticatedPartners();
  const variables = {
    apiKey,
    deploymentUuid: deploymentUUID,
    bundleFormat: 1
  };
  const result = await api.partners.request(mutation, token, variables);
  if (result.deploymentGenerateSignedUploadUrl?.userErrors?.length > 0) {
    const errors = result.deploymentGenerateSignedUploadUrl.userErrors.map((error2) => error2.message).join(", ");
    throw new error.Abort(errors);
  }
  return result.deploymentGenerateSignedUploadUrl.signedUploadUrl;
}
async function uploadFunctionExtensions(extensions, options) {
  let identifiers = options.identifiers;
  const functionUUIDs = {};
  for (const extension of extensions) {
    const remoteIdentifier = await uploadFunctionExtension(extension, {
      apiKey: options.identifiers.app,
      token: options.token,
      identifier: identifiers.extensions[extension.localIdentifier]
    });
    functionUUIDs[extension.localIdentifier] = remoteIdentifier;
  }
  identifiers = {
    ...identifiers,
    extensions: {
      ...identifiers.extensions,
      ...functionUUIDs
    }
  };
  return identifiers;
}
async function uploadFunctionExtension(extension, options) {
  const { url, headers } = await getFunctionExtensionUploadURL({ apiKey: options.apiKey, token: options.token });
  headers["Content-Type"] = "application/wasm";
  let inputQuery;
  if (await file.exists(extension.inputQueryPath())) {
    inputQuery = await file.read(extension.inputQueryPath());
  }
  const functionContent = fs.readFileSync(extension.buildWasmPath());
  await http.fetch(url, { body: functionContent, headers, method: "PUT" });
  await compileFunctionExtension(extension, options, url);
  const query = api.graphql.AppFunctionSetMutation;
  const schemaVersions = Object.values(extension.metadata.schemaVersions).shift();
  const schemaMajorVersion = schemaVersions?.major;
  const schemaMinorVersion = schemaVersions?.minor;
  const variables = {
    uuid: options.identifier,
    extensionPointName: getFunctionExtensionPointName(extension.configuration.type),
    title: extension.configuration.name,
    description: extension.configuration.description,
    force: true,
    schemaMajorVersion: schemaMajorVersion === void 0 ? "" : `${schemaMajorVersion}`,
    schemaMinorVersion: schemaMinorVersion === void 0 ? "" : `${schemaMinorVersion}`,
    configurationUi: extension.configuration.configurationUi,
    moduleUploadUrl: url,
    apiVersion: extension.configuration.apiVersion,
    skipCompilationJob: true,
    appBridge: extension.configuration.ui?.paths ? {
      detailsPath: extension.configuration.ui.paths.details,
      createPath: extension.configuration.ui.paths.create
    } : void 0,
    inputQuery
  };
  const res = await api.partners.functionProxyRequest(options.apiKey, query, options.token, variables);
  const userErrors = res.data.appScriptSet.userErrors ?? [];
  if (userErrors.length !== 0) {
    const errorMessage = output.content`The deployment of functions failed with the following errors:
${output.token.json(userErrors)}
    `;
    throw new error.Abort(errorMessage);
  }
  const uuid = res.data.appScriptSet.appScript?.uuid;
  return uuid;
}
async function compileFunctionExtension(extension, options, moduleUploadUrl) {
  const query = api.graphql.CompileModuleMutation;
  const variables = {
    moduleUploadUrl
  };
  const res = await api.partners.functionProxyRequest(options.apiKey, query, options.token, variables);
  const jobId = res.data.compileModule.jobId;
  await waitForCompilation(extension, options, jobId);
}
async function getCompilationStatus(options, compilationJobId) {
  const query = api.graphql.ModuleCompilationStatusQuery;
  const variables = {
    jobId: compilationJobId
  };
  const res = await api.partners.functionProxyRequest(options.apiKey, query, options.token, variables);
  return res.data.moduleCompilationStatus.status;
}
async function waitForCompilation(extension, options, compilationJobId) {
  let retries = 0;
  const poll = async () => {
    const compilationStatus = await getCompilationStatus(options, compilationJobId);
    if (compilationStatus === "completed") ; else if (compilationStatus !== "pending") {
      throw new error.Abort(output.content`Function ${extension.localIdentifier} compilation failed.`);
    } else if (retries < blocks.functions.maxCompilationStatusCheckCount) {
      retries++;
      return sleep(blocks.functions.compilationStatusWaitMs).then(() => poll());
    } else {
      throw new error.Abort(output.content`Function ${extension.localIdentifier} compilation timed out.`);
    }
  };
  return poll();
}
function sleep(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
async function getFunctionExtensionUploadURL(options) {
  const query = api.graphql.ModuleUploadUrlGenerateMutation;
  const res = await api.partners.functionProxyRequest(options.apiKey, query, options.token);
  return res.data.moduleUploadUrlGenerate.details;
}

const L10N_FILE_SIZE_LIMIT = 16 * 1024;
const L10N_BUNDLE_SIZE_LIMIT = 256 * 1024;
const MissingDefaultLanguageError = () => {
  return new error.Abort("Missing default language in checkout_ui_extension configuration", "Make sure to have a {locale}.default.json file in your locales directory");
};
const BigBundleError = () => {
  return new error.Abort(`Error loading checkout_ui_extension`, `Total size of all locale files must be less than ${L10N_BUNDLE_SIZE_LIMIT}`);
};
const BigFileError = (filename) => {
  return new error.Abort(`Error loading checkout_ui_extension`, `Locale file ${filename} size must be less than ${L10N_FILE_SIZE_LIMIT}`);
};
const EmptyFileError = (filename) => {
  return new error.Abort(`Error loading checkout_ui_extension`, `Locale file ${filename} can't be empty`);
};
const MultipleDefaultError = () => {
  return new error.Abort(`Error loading checkout_ui_extension`, `There must be one (and only one) locale identified as the default locale: e.g. "en.default.json"`);
};
async function loadLocalesConfig(extensionPath) {
  const localesPaths = await path.glob(path.join(extensionPath, "locales/*.json"));
  if (localesPaths.length === 0)
    return {};
  const totalBundleSize = bundleSize(localesPaths);
  const defaultLanguageCode = findDefaultLocale(localesPaths);
  if (defaultLanguageCode.length === 0)
    throw MissingDefaultLanguageError();
  if (defaultLanguageCode.length > 1)
    throw MultipleDefaultError();
  if (totalBundleSize > L10N_BUNDLE_SIZE_LIMIT)
    throw BigBundleError();
  for (const locale of localesPaths) {
    const size = fs.statSync(locale).size;
    if (size > L10N_FILE_SIZE_LIMIT)
      throw BigFileError(locale);
    if (size === 0)
      throw EmptyFileError(locale);
  }
  return {
    default_locale: defaultLanguageCode[0],
    translations: getAllLocales(localesPaths)
  };
}
function findDefaultLocale(filePaths) {
  const defaultLocale = filePaths.filter((locale) => path.basename(locale).endsWith(".default.json"));
  return defaultLocale.map((locale) => path.basename(locale).split(".")[0]);
}
function getAllLocales(localesPath) {
  const all = {};
  for (const localePath of localesPath) {
    const localeCode = path.basename(localePath).split(".")[0];
    const locale = fs.readFileSync(localePath, "base64");
    all[localeCode] = locale;
  }
  return all;
}
function bundleSize(localesPaths) {
  return localesPaths.map((locale) => fs.statSync(locale).size).reduce((acc, size) => acc + size, 0);
}

const FunctionsWithMissingWasm = (extensions) => {
  const extensionLine = (extension) => {
    return output.stringifyMessage(output.content`· ${output.token.green(extension.id)}: ${output.token.path(extension.path)}`);
  };
  const extensionLines = output.token.raw(extensions.map(extensionLine).join("\n"));
  return new error.Abort(output.content`The following function extensions haven't compiled the wasm in the expected path:
  ${extensionLines}
      `, `Make sure the build command outputs the wasm in the expected directory.`);
};
async function validateFunctionExtensions(extensions) {
  await validateFunctionsWasmPresence(extensions);
}
async function validateFunctionsWasmPresence(extensions) {
  const extensionsWithoutWasm = (await Promise.all(extensions.map(async (extension) => {
    const wasmPath = extension.buildWasmPath();
    return await file.exists(wasmPath) ? void 0 : {
      id: extension.localIdentifier,
      path: extension.buildWasmPath()
    };
  }))).filter((extension) => extension !== void 0);
  if (extensionsWithoutWasm.length !== 0) {
    throw FunctionsWithMissingWasm(extensionsWithoutWasm);
  }
}

const WebPixelConfigError = (property) => {
  return new error.Abort(`The Web Pixel Extension configuration is missing the key "${property}"`, `Please update your shopify.ui.extension.toml to include a valid "${property}"`);
};
function validateUIExtensions(extensions) {
  for (const extension of extensions) {
    switch (extension.type) {
      case "web_pixel_extension":
        validateWebPixelConfig(extension);
        break;
    }
  }
}
function validateWebPixelConfig(extension) {
  if (!extension.configuration.runtimeContext) {
    throw WebPixelConfigError("runtime_context");
  }
  if (!extension.configuration.configuration) {
    throw WebPixelConfigError("configuration");
  }
}

const kilobytes = 1024;
const megabytes = kilobytes * 1024;
const BUNDLE_SIZE_LIMIT_MB = 10;
const BUNDLE_SIZE_LIMIT = BUNDLE_SIZE_LIMIT_MB * megabytes;
const LIQUID_SIZE_LIMIT_KB = 100;
const LIQUID_SIZE_LIMIT = LIQUID_SIZE_LIMIT_KB * kilobytes;
const SUPPORTED_ASSET_EXTS = [".jpg", ".js", ".css", ".png", ".svg"];
const SUPPORTED_LOCALE_EXTS = [".json"];
const SUPPORTED_EXTS = {
  assets: {
    validator: new RegExp(`${SUPPORTED_ASSET_EXTS.join("|")}$`),
    failureMessage: (filename) => `Only these filetypes are supported in assets: ${SUPPORTED_ASSET_EXTS.join(", ")}`
  },
  blocks: {
    validator: /.liquid$/,
    failureMessage: (filename) => `Only .liquid files are allowed in blocks.`
  },
  locales: {
    validator: new RegExp(`${SUPPORTED_LOCALE_EXTS.join("|")}$`),
    failureMessage: (filename) => `Only these filetypes are supported in locales: ${SUPPORTED_LOCALE_EXTS.join(", ")}`
  },
  snippets: {
    validator: /.liquid$/,
    failureMessage: (filename) => `Only .liquid files are allowed in snippets.`
  }
};
const SUPPORTED_BUCKETS = Object.keys(SUPPORTED_EXTS);
async function validateThemeExtensions(extensions) {
  await Promise.all(extensions.map((extension) => validateThemeExtension(extension)));
}
async function validateThemeExtension(extension) {
  const themeFiles = await path.glob(path.join(extension.directory, "*/*"));
  const liquidBytes = [];
  const extensionBytes = [];
  await Promise.all(themeFiles.map(async (filepath) => {
    const relativePath = path.relative(extension.directory, filepath);
    const dirname = path.dirname(relativePath);
    validateFile(relativePath, dirname);
    const filesize = await file.size(filepath);
    extensionBytes.push(filesize);
    if (["blocks", "snippets"].includes(dirname))
      liquidBytes.push(filesize);
  }));
  validateExtensionBytes(arraySum(extensionBytes));
  validateLiquidBytes(arraySum(liquidBytes));
}
function validateExtensionBytes(extensionBytesTotal) {
  if (extensionBytesTotal > BUNDLE_SIZE_LIMIT) {
    const humanBundleSize = `${(extensionBytesTotal / megabytes).toFixed(2)} MB`;
    throw new error.Abort(`Your theme app extension exceeds the file size limit (${BUNDLE_SIZE_LIMIT_MB} MB). It's currently ${humanBundleSize}.`, `Reduce your total file size and try again.`);
  }
}
function validateLiquidBytes(liquidBytesTotal) {
  if (liquidBytesTotal > LIQUID_SIZE_LIMIT) {
    const humanLiquidSize = `${(liquidBytesTotal / kilobytes).toFixed(2)} kB`;
    throw new error.Abort(`Your theme app extension exceeds the total liquid file size limit (${LIQUID_SIZE_LIMIT_KB} kB). It's currently ${humanLiquidSize}.`, `Reduce your total file size and try again.`);
  }
}
function validateFile(filepath, dirname) {
  if (!SUPPORTED_BUCKETS.includes(dirname)) {
    throw new error.Abort(output.content`Your theme app extension includes files in an unsupported directory, ${output.token.path(dirname)}`, `Make sure all theme app extension files are in the supported directories: ${SUPPORTED_BUCKETS.join(", ")}`);
  }
  const filenameValidation = SUPPORTED_EXTS[dirname];
  if (!filepath.match(filenameValidation.validator)) {
    throw new error.Abort(`Invalid filename in your theme app extension: ${filepath}
${filenameValidation.failureMessage(filepath)}`);
  }
}
function arraySum(array) {
  return array.reduce((num1, num2) => num1 + num2, 0);
}

async function validateExtensions(app) {
  await Promise.all([
    validateFunctionExtensions(app.extensions.function),
    validateUIExtensions(app.extensions.ui),
    validateThemeExtensions(app.extensions.theme)
  ]);
}

const RendererNotFoundBug = (extension) => {
  return new error.Bug(`Couldn't find renderer version for extension ${extension}`, "Make sure you have all your dependencies up to date");
};
const deploy = async (options) => {
  if (!hasExtensions(options.app)) {
    output.newline();
    output.info(`No extensions to deploy to Shopify Partners yet.`);
    return;
  }
  let { app, identifiers, partnersApp, partnersOrganizationId, token } = await ensureDeployEnvironment(options);
  const apiKey = identifiers.app;
  output.newline();
  output.info(`Deploying your work to Shopify Partners. It will be part of ${partnersApp.title}`);
  output.newline();
  const extensions = await Promise.all(options.app.extensions.ui.map(async (extension) => {
    return {
      uuid: identifiers.extensions[extension.localIdentifier],
      config: JSON.stringify(await configFor(extension, app)),
      context: ""
    };
  }));
  await temporary.directory(async (tmpDir) => {
    try {
      const bundlePath = path.join(tmpDir, `bundle.zip`);
      await file.mkdir(path.dirname(bundlePath));
      const bundle = app.extensions.ui.length !== 0;
      await bundleUIAndBuildFunctionExtensions({ app, bundlePath, identifiers, bundle });
      output.newline();
      output.info(`Running validation\u2026`);
      await validateExtensions(app);
      output.newline();
      output.info(`Pushing your code to Shopify\u2026`);
      output.newline();
      if (bundle) {
        await uploadUIExtensionsBundle({ apiKey, bundlePath, extensions, token });
      }
      await uploadThemeExtensions(options.app.extensions.theme, { apiKey, identifiers, token });
      identifiers = await uploadFunctionExtensions(app.extensions.function, { identifiers, token });
      app = await updateAppIdentifiers({ app, identifiers, command: "deploy" });
      output.success("Deployed to Shopify");
      const registrations = await fetchAppExtensionRegistrations({ token, apiKey: identifiers.app });
      outputCompletionMessage({ app, partnersApp, partnersOrganizationId, identifiers, registrations });
    } catch (error2) {
      await updateAppIdentifiers({ app, identifiers, command: "deploy" });
      throw error2;
    }
  });
};
async function outputCompletionMessage({
  app,
  partnersApp,
  partnersOrganizationId,
  identifiers,
  registrations
}) {
  output.newline();
  output.info("  Summary:");
  const outputDeployedButNotLiveMessage = (extension) => {
    output.info(output.content`    · ${extension.localIdentifier} is deployed to Shopify but not yet live`);
  };
  const outputDeployedAndLivedMessage = (extension) => {
    output.info(output.content`    · ${extension.localIdentifier} is live`);
  };
  app.extensions.ui.forEach(outputDeployedButNotLiveMessage);
  app.extensions.theme.forEach(outputDeployedButNotLiveMessage);
  app.extensions.function.forEach(outputDeployedAndLivedMessage);
  output.newline();
  const outputNextStep = async (extension) => {
    const extensionId = registrations.app.extensionRegistrations.find((registration) => {
      return registration.uuid === identifiers.extensions[extension.localIdentifier];
    })?.id ?? "";
    return output.content`    · Publish ${output.token.link(extension.localIdentifier, await getExtensionPublishURL({ extension, partnersApp, partnersOrganizationId, extensionId }))}`;
  };
  if (app.extensions.ui.length !== 0 || app.extensions.function.length !== 0) {
    const lines = await Promise.all([...app.extensions.ui, ...app.extensions.theme].map(outputNextStep));
    if (lines.length > 0) {
      output.info("  Next steps in Shopify Partners:");
      lines.forEach(output.info);
    }
  }
}
async function configFor(extension, app) {
  const type = extension.type;
  switch (extension.type) {
    case "checkout_post_purchase":
      return { metafields: extension.configuration.metafields };
    case "pos_ui_extension":
    case "product_subscription": {
      const result = await getUIExtensionRendererVersion(type, app);
      if (result === "not_found")
        throw RendererNotFoundBug(type);
      return { renderer_version: result?.version };
    }
    case "checkout_ui_extension": {
      return {
        extension_points: extension.configuration.extensionPoints,
        capabilities: extension.configuration.capabilities,
        metafields: extension.configuration.metafields,
        name: extension.configuration.name,
        localization: await loadLocalesConfig(extension.directory)
      };
    }
    case "web_pixel_extension": {
      return {
        runtime_context: extension.configuration.runtimeContext,
        runtime_configuration_definition: extension.configuration.configuration
      };
    }
  }
}
async function getExtensionPublishURL({
  extension,
  partnersApp,
  partnersOrganizationId,
  extensionId
}) {
  const partnersFqdn = await environment.fqdn.partners();
  if (isUiExtensionType(extension.type)) {
    let pathComponent;
    switch (extension.type) {
      case "checkout_ui_extension":
      case "pos_ui_extension":
      case "product_subscription":
        pathComponent = extension.type;
        break;
      case "checkout_post_purchase":
        pathComponent = "post_purchase";
        break;
      case "web_pixel_extension":
        pathComponent = "web_pixel";
        break;
    }
    return `https://${partnersFqdn}/${partnersOrganizationId}/apps/${partnersApp.id}/extensions/${pathComponent}/${extensionId}`;
  } else if (isFunctionExtensionType(extension.type)) {
    return `https://${partnersFqdn}/${partnersOrganizationId}/apps/${partnersApp.id}/extensions`;
  } else if (isThemeExtensionType(extension.type)) {
    return `https://${partnersFqdn}/${partnersOrganizationId}/apps/${partnersApp.id}/extensions/theme_app_extension/${extensionId}`;
  } else {
    return "";
  }
}

const _Deploy = class extends Command {
  async run() {
    const { args, flags } = await this.parse(_Deploy);
    const directory = flags.path ? path.resolve(flags.path) : process.cwd();
    const app = await load(directory);
    await deploy({ app, reset: flags.reset });
  }
};
let Deploy = _Deploy;
Deploy.description = "Deploy your Shopify app";
Deploy.flags = {
  ...cli.globalFlags,
  ...appFlags,
  reset: Flags.boolean({
    hidden: false,
    description: "Reset all your settings.",
    env: "SHOPIFY_FLAG_RESET",
    default: false
  })
};

export { Deploy as default };
//# sourceMappingURL=deploy.js.map
