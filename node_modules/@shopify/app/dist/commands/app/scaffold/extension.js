import { r as uiExtensionTemplates, i as isUiExtensionType, n as getExtensionOutputConfig, f as isFunctionExtensionType, t as themeExtensions, p as functionExtensions, s as functionExtensionTemplates, w as extensions, o as uiExtensions, x as extensionTypeCategory, c as blocks, v as versions, y as getUIExtensionRendererDependency, a as appFlags, l as load, z as limitedExtensions } from '../../../app-5df50971.js';
import { environment, haiku, ui, template, dependency, yaml, file, path, git, string, error, cli, output } from '@shopify/cli-kit';
import { r as runGoExtensionsCLI } from '../../../cli-925c35a7.js';
import { fileURLToPath } from 'url';
import stream from 'node:stream';
import { Flags, Command } from '@oclif/core';
import 'node:zlib';
import 'node:fs';
import 'node:util';

function getUIExtensionTemplates(extensionType) {
  const filteredFlavors = [];
  if (extensionType === "web_pixel_extension") {
    filteredFlavors.push("react");
  }
  return uiExtensionTemplates.filter((template) => !filteredFlavors.includes(template.value));
}
function isValidUIExtensionTemplate(extensionType, uiExtensionTemplateValue) {
  return isUiExtensionType(extensionType) && Boolean(getUIExtensionTemplates(extensionType).find((extensionTemplate) => extensionTemplate.value === uiExtensionTemplateValue));
}

const extensionFlavorQuestion = (extensionType) => {
  let choices = [];
  if (isUiExtensionType(extensionType)) {
    choices = choices.concat(getUIExtensionTemplates(extensionType));
  }
  if (isFunctionExtensionType(extensionType)) {
    choices = choices.concat(functionExtensionTemplates);
  }
  return {
    type: "select",
    name: "extensionFlavor",
    message: "Choose a starting template for your extension",
    choices,
    default: "react"
  };
};
const scaffoldExtensionPrompt = async (options, prompt = ui.prompt) => {
  const questions = [];
  const isShopify = await environment.local.isShopify();
  const supportedExtensions = isShopify ? extensions.types : extensions.publicTypes;
  if (!options.extensionType) {
    let relevantExtensionTypes = supportedExtensions.filter((type) => !options.extensionTypesAlreadyAtQuota.includes(type));
    if (options.extensionFlavor) {
      relevantExtensionTypes = relevantExtensionTypes.filter((relevantExtensionType) => isValidUIExtensionTemplate(relevantExtensionType, options.extensionFlavor));
    }
    questions.push({
      type: "select",
      name: "extensionType",
      message: "Type of extension?",
      choices: relevantExtensionTypes.map((type) => ({
        name: getExtensionOutputConfig(type).humanKey,
        value: type
      })).sort(extensionTypeChoiceSorterByGroupAndName)
    });
  }
  if (!options.name) {
    questions.push({
      type: "input",
      name: "name",
      message: "Your extension's working name?",
      default: haiku.generate("ext")
    });
  }
  let promptOutput = await prompt(questions);
  const extensionType = { ...options, ...promptOutput }.extensionType;
  if (!options.extensionFlavor && (isUiExtensionType(extensionType) || isFunctionExtensionType(extensionType))) {
    promptOutput = {
      ...promptOutput,
      extensionFlavor: (await prompt([
        extensionFlavorQuestion(extensionType)
      ])).extensionFlavor
    };
  }
  return { ...options, ...promptOutput };
};
const extensionTypeChoiceSorterByGroupAndName = (c1, c2) => {
  const c1ExtensiontyCategoryPosition = extensiontypeCategoryPosition(c1.value);
  const c2ExtensiontyCategoryPosition = extensiontypeCategoryPosition(c2.value);
  if (c1ExtensiontyCategoryPosition === c2ExtensiontyCategoryPosition) {
    return c1.name.localeCompare(c2.name);
  } else {
    return c1ExtensiontyCategoryPosition < c2ExtensiontyCategoryPosition ? -1 : 1;
  }
};
const extensiontypeCategoryPosition = (extensionType) => {
  if (includes(uiExtensions.types, extensionType) || includes(themeExtensions.types, extensionType)) {
    return 0;
  } else if (includes(functionExtensions.types, extensionType)) {
    return 1;
  } else {
    return Number.MAX_VALUE;
  }
};
function includes(coll, el) {
  return coll.includes(el);
}

async function getTemplatePath(name) {
  const templatePath = await path.findUp(`templates/${name}`, {
    cwd: path.dirname(fileURLToPath(import.meta.url)),
    type: "directory"
  });
  if (templatePath) {
    return templatePath;
  } else {
    throw new error.Bug(`Couldn't find the template ${name} in @shopify/app.`);
  }
}
async function extensionInit(options) {
  const extensionDirectory = await ensureExtensionDirectoryExists({ app: options.app, name: options.name });
  switch (extensionTypeCategory(options.extensionType)) {
    case "theme":
      await themeExtensionInit({ ...options, extensionDirectory });
      break;
    case "function":
      await functionExtensionInit({ ...options, extensionDirectory });
      break;
    case "ui":
      await uiExtensionInit({ ...options, extensionDirectory });
      break;
  }
  return extensionDirectory;
}
async function themeExtensionInit({ name, app, extensionType, extensionDirectory }) {
  const templatePath = await getTemplatePath("theme-extension");
  await template.recursiveDirectoryCopy(templatePath, extensionDirectory, { name, extensionType });
}
async function uiExtensionInit({
  name,
  extensionType,
  app,
  extensionFlavor,
  extensionDirectory
}) {
  const list = new ui.Listr([
    {
      title: "Install additional dependencies",
      task: async (_, task) => {
        task.title = "Installing additional dependencies...";
        const requiredDependencies = getRuntimeDependencies({ extensionType });
        await dependency.addNPMDependenciesIfNeeded(requiredDependencies, {
          dependencyManager: app.dependencyManager,
          type: "prod",
          directory: app.directory,
          stderr: new stream.Writable({
            write(chunk, encoding, next) {
              task.output = chunk.toString();
              next();
            }
          }),
          stdout: new stream.Writable({
            write(chunk, encoding, next) {
              task.output = chunk.toString();
              next();
            }
          })
        });
        task.title = "Dependencies installed";
      }
    },
    {
      title: `Scaffold ${getExtensionOutputConfig(extensionType).humanKey} extension`,
      task: async (_, task) => {
        task.title = `Scaffolding ${getExtensionOutputConfig(extensionType).humanKey} extension...`;
        const stdin = yaml.encode({
          extensions: [
            {
              title: name,
              type: `${extensionType}_next`,
              metafields: [],
              development: {
                root_dir: ".",
                template: extensionFlavor
              }
            }
          ]
        });
        await runGoExtensionsCLI(["create", "-"], {
          cwd: extensionDirectory,
          stderr: new stream.Writable({
            write(chunk, encoding, next) {
              task.output = chunk.toString();
              next();
            }
          }),
          stdout: new stream.Writable({
            write(chunk, encoding, next) {
              task.output = chunk.toString();
              next();
            }
          }),
          stdin
        });
        task.title = `${getExtensionOutputConfig(extensionType).humanKey} extension scaffolded`;
      }
    }
  ], { rendererSilent: environment.local.isUnitTest() });
  await list.run();
}
function getRuntimeDependencies({
  extensionType
}) {
  switch (extensionType) {
    case "product_subscription":
    case "checkout_ui_extension":
    case "pos_ui_extension":
    case "web_pixel_extension":
    case "checkout_post_purchase": {
      const dependencies = [{ name: "react", version: versions.react }];
      const rendererDependency = getUIExtensionRendererDependency(extensionType);
      if (rendererDependency) {
        dependencies.push(rendererDependency);
      }
      return dependencies;
    }
  }
}
async function functionExtensionInit(options) {
  const url = options.cloneUrl || blocks.functions.defaultUrl;
  await file.inTemporaryDirectory(async (tmpDir) => {
    const templateDownloadDir = path.join(tmpDir, "download");
    const list = new ui.Listr([
      {
        title: `Scaffolding ${getExtensionOutputConfig(options.extensionType).humanKey} extension...`,
        task: async (_, task) => {
          await file.mkdir(templateDownloadDir);
          await git.downloadRepository({
            repoUrl: url,
            destination: templateDownloadDir,
            shallow: true,
            progressUpdater: (statusString) => {
              const taskOutput = `Cloning template from ${url}:
${statusString}`;
              task.output = taskOutput;
            }
          });
          const origin = path.join(templateDownloadDir, functionTemplatePath(options));
          await template.recursiveDirectoryCopy(origin, options.extensionDirectory, options);
          const configYamlPath = path.join(options.extensionDirectory, "script.config.yml");
          if (await file.exists(configYamlPath)) {
            await file.remove(configYamlPath);
          }
          task.title = `${getExtensionOutputConfig(options.extensionType).humanKey} extension scaffolded`;
        }
      }
    ], { rendererSilent: environment.local.isUnitTest() });
    await list.run();
  });
}
function functionTemplatePath({ extensionType, extensionFlavor }) {
  const lang = extensionFlavor || blocks.functions.defaultLanguage;
  switch (extensionType) {
    case "product_discounts":
      return `discounts/${lang}/product-discounts/default`;
    case "order_discounts":
      return `discounts/${lang}/order-discounts/default`;
    case "shipping_discounts":
      return `discounts/${lang}/shipping-discounts/default`;
    case "payment_methods":
      return `checkout/${lang}/payment-methods/default`;
    case "shipping_rate_presenter":
      return `checkout/${lang}/shipping-rate-presenter/default`;
  }
}
async function ensureExtensionDirectoryExists({ name, app }) {
  const hyphenizedName = string.hyphenize(name);
  const extensionDirectory = path.join(app.directory, blocks.extensions.directoryName, hyphenizedName);
  if (await file.exists(extensionDirectory)) {
    throw new error.Abort(`
A directory with this name (${hyphenizedName}) already exists.
Choose a new name for your extension.`);
  }
  await file.mkdir(extensionDirectory);
  return extensionDirectory;
}

const _AppScaffoldExtension = class extends Command {
  async run() {
    const { flags } = await this.parse(_AppScaffoldExtension);
    const directory = flags.path ? path.resolve(flags.path) : process.cwd();
    const app = await load(directory);
    await this.validateExtensionType(flags.type);
    this.validateExtensionTypeLimit(app, flags.type);
    const extensionFlavor = flags.template;
    this.validateExtensionFlavor(flags.type, extensionFlavor);
    const promptAnswers = await scaffoldExtensionPrompt({
      extensionType: flags.type,
      extensionTypesAlreadyAtQuota: this.limitedExtensionsAlreadyScaffolded(app),
      name: flags.name,
      extensionFlavor
    });
    const extensionDirectory = await extensionInit({
      ...promptAnswers,
      extensionType: promptAnswers.extensionType,
      app,
      cloneUrl: flags["clone-url"]
    });
    const formattedSuccessfulMessage = this.formatSuccessfulRunMessage(promptAnswers.extensionType, path.relative(app.directory, extensionDirectory), app.dependencyManager);
    output.info(formattedSuccessfulMessage);
  }
  async validateExtensionType(type) {
    if (!type) {
      return;
    }
    const isShopify = await environment.local.isShopify();
    const supportedExtensions = isShopify ? extensions.types : extensions.publicTypes;
    if (!supportedExtensions.includes(type)) {
      throw new error.Abort(`Invalid extension type ${type}`, `The following extension types are supported: ${supportedExtensions.join(", ")}`);
    }
  }
  validateExtensionTypeLimit(app, type) {
    if (type && this.limitedExtensionsAlreadyScaffolded(app).includes(type)) {
      throw new error.Abort("Invalid extension type", `You can only scaffold one extension of type ${type} per app`);
    }
  }
  validateExtensionFlavor(type, flavor) {
    if (!flavor || !type) {
      return;
    }
    const uiExtensionTemplateNames = getUIExtensionTemplates(type).map((template) => template.value);
    const functionExtensionTemplateNames = functionExtensionTemplates.map((template) => template.value);
    const invalidTemplateError = (templates) => {
      return new error.Abort("Specified extension template on invalid extension type", `You can only specify a template for these extension types: ${templates.join(", ")}.`);
    };
    if (isUiExtensionType(type) && !uiExtensionTemplateNames.includes(flavor)) {
      throw invalidTemplateError(uiExtensionTemplateNames);
    }
    if (isFunctionExtensionType(type) && !functionExtensionTemplateNames.includes(flavor)) {
      throw invalidTemplateError(functionExtensionTemplateNames);
    }
  }
  limitedExtensionsAlreadyScaffolded(app) {
    const themeTypes = app.extensions.theme.map((ext) => ext.configuration.type);
    const uiTypes = app.extensions.ui.map((ext) => ext.configuration.type);
    const themeExtensions = themeTypes.filter((type) => limitedExtensions.theme.includes(type));
    const uiExtensions = uiTypes.filter((type) => limitedExtensions.ui.includes(type));
    return [...themeExtensions, ...uiExtensions];
  }
  formatSuccessfulRunMessage(extensionType, extensionDirectory, depndencyManager) {
    const extensionOutputConfig = getExtensionOutputConfig(extensionType);
    output.completed(`Your ${extensionOutputConfig.humanKey} extension was added to your project!`);
    const outputTokens = [];
    outputTokens.push(output.content`\n  To find your extension, remember to ${output.token.genericShellCommand(output.content`cd ${output.token.path(extensionDirectory)}`)}`.value);
    if (isUiExtensionType(extensionType)) {
      outputTokens.push(output.content`  To preview your project, run ${output.token.packagejsonScript(depndencyManager, "dev")}`.value);
    }
    if (extensionOutputConfig.additionalHelp) {
      outputTokens.push(`  ${extensionOutputConfig.additionalHelp}`);
    }
    if (extensionOutputConfig.helpURL) {
      outputTokens.push(output.content`  For more details, see the ${output.token.link("docs", extensionOutputConfig.helpURL)} ✨`.value);
    }
    return outputTokens.join("\n").concat("\n");
  }
};
let AppScaffoldExtension = _AppScaffoldExtension;
AppScaffoldExtension.description = "Scaffold an Extension";
AppScaffoldExtension.examples = ["<%= config.bin %> <%= command.id %>"];
AppScaffoldExtension.flags = {
  ...cli.globalFlags,
  ...appFlags,
  type: Flags.string({
    char: "t",
    hidden: false,
    description: `Extension type
<options: ${extensions.publicTypes.join("|")}>`,
    env: "SHOPIFY_FLAG_EXTENSION_TYPE"
  }),
  name: Flags.string({
    char: "n",
    hidden: false,
    description: "name of your Extension",
    env: "SHOPIFY_FLAG_NAME"
  }),
  "clone-url": Flags.string({
    hidden: true,
    char: "u",
    description: "The Git URL to clone the function extensions templates from. Defaults to: https://github.com/Shopify/function-examples",
    env: "SHOPIFY_FLAG_CLONE_URL"
  }),
  template: Flags.string({
    hidden: false,
    description: "Choose a starting template for your extension, where applicable",
    options: ["vanilla-js", "react", "wasm", "rust"],
    env: "SHOPIFY_FLAG_TEMPLATE"
  })
};
AppScaffoldExtension.args = [{ name: "file" }];

export { AppScaffoldExtension as default };
//# sourceMappingURL=extension.js.map
