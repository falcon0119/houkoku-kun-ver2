import { Flags } from '@oclif/core';
import { path, schema, string, dotenv, dependency, file, error, output, toml, id } from '@shopify/cli-kit';

const appFlags = {
  path: Flags.string({
    hidden: false,
    description: "The path to your app directory.",
    parse: (input, _) => Promise.resolve(path.resolve(input)),
    env: "SHOPIFY_FLAG_PATH"
  })
};

const configurationFileNames = {
  app: "shopify.app.toml",
  extension: {
    ui: "shopify.ui.extension.toml",
    theme: "shopify.theme.extension.toml",
    function: "shopify.function.extension.toml"
  },
  web: "shopify.web.toml"
};
const dotEnvFileNames = {
  production: ".env"
};
const environmentVariables = {
  useExtensionsCLISources: "SHOPIFY_USE_EXTENSIONS_CLI_SOURCES"
};
const versions = {
  extensionsBinary: "v0.20.2",
  react: "^17.0.0"
};
const blocks = {
  extensions: {
    directoryName: "extensions",
    configurationName: configurationFileNames.extension
  },
  functions: {
    defaultUrl: "https://github.com/Shopify/function-examples",
    defaultLanguage: "wasm",
    maxCompilationStatusCheckCount: 7,
    compilationStatusWaitMs: 2e3
  },
  web: {
    directoryName: "web",
    configurationName: configurationFileNames.web
  }
};
const limitedExtensions = {
  ui: ["product_subscription", "checkout_post_purchase", "web_pixel_extension"],
  theme: ["theme"],
  function: []
};
const publicFunctionExtensions = {
  types: ["product_discounts", "order_discounts", "shipping_discounts"]
};
const functionExtensions = {
  types: [...publicFunctionExtensions.types, "payment_methods", "shipping_rate_presenter"]
};
const functionExtensionTemplates = [
  { name: "Wasm", value: "wasm" },
  { name: "Rust", value: "rust" }
];
function isFunctionExtensionType(extensionType) {
  return functionExtensions.types.includes(extensionType);
}
const publicUIExtensions = {
  types: ["product_subscription", "checkout_ui_extension", "checkout_post_purchase", "web_pixel_extension"]
};
const uiExtensions = {
  types: [...publicUIExtensions.types, "pos_ui_extension"]
};
const uiExtensionTemplates = [
  { name: "React", value: "react" },
  { name: "vanilla JavaScript", value: "vanilla-js" }
];
function isUiExtensionType(extensionType) {
  return uiExtensions.types.includes(extensionType);
}
const themeExtensions = {
  types: ["theme"]
};
function isThemeExtensionType(extensionType) {
  return themeExtensions.types.includes(extensionType);
}
const extensions = {
  types: [...themeExtensions.types, ...uiExtensions.types, ...functionExtensions.types],
  publicTypes: [...themeExtensions.types, ...publicUIExtensions.types, ...publicFunctionExtensions.types]
};
function extensionTypeCategory(extensionType) {
  if (extensionType === "theme") {
    return "theme";
  }
  if (functionExtensions.types.includes(extensionType)) {
    return "function";
  }
  return "ui";
}
const getFunctionExtensionPointName = (type) => {
  switch (type) {
    case "product_discounts":
      return "PRODUCT_DISCOUNTS";
    case "order_discounts":
      return "ORDER_DISCOUNTS";
    case "shipping_discounts":
      return "SHIPPING_DISCOUNTS";
    case "payment_methods":
      return "PAYMENT_METHODS";
    case "shipping_rate_presenter":
      return "SHIPPING_METHODS";
  }
};
function getUIExtensionRendererDependency(extensionType) {
  switch (extensionType) {
    case "product_subscription":
      return { name: "@shopify/admin-ui-extensions-react", version: "^1.0.1" };
    case "checkout_ui_extension":
      return { name: "@shopify/checkout-ui-extensions-react", version: "^0.17.0" };
    case "checkout_post_purchase":
      return { name: "@shopify/post-purchase-ui-extensions-react", version: "^0.13.2" };
    case "pos_ui_extension":
      return { name: "@shopify/retail-ui-extensions-react", version: "^0.1.0" };
    case "web_pixel_extension":
      return { name: "@shopify/web-pixels-extension", version: "^0.1.1" };
  }
}
function getExtensionOutputConfig(extensionType) {
  switch (extensionType) {
    case "web_pixel_extension":
      return buildExtensionOutputConfig("web pixel");
    case "checkout_post_purchase":
      return buildExtensionOutputConfig("post-purchase UI", "https://shopify.dev/apps/checkout/post-purchase");
    case "theme":
      return buildExtensionOutputConfig("theme app extension");
    case "checkout_ui_extension":
      return buildExtensionOutputConfig("checkout UI");
    case "product_subscription":
      return buildExtensionOutputConfig("subscription UI");
    case "pos_ui_extension":
      return buildExtensionOutputConfig("POS UI");
    case "product_discounts":
      return buildExtensionOutputConfig("product discount", "https://shopify.dev/apps/subscriptions/discounts");
    case "order_discounts":
      return buildExtensionOutputConfig("order discount", "https://shopify.dev/apps/subscriptions/discounts");
    case "shipping_discounts":
      return buildExtensionOutputConfig("shipping discount", "https://shopify.dev/apps/subscriptions/discounts");
    case "payment_methods":
      return buildExtensionOutputConfig("payment customization");
    case "shipping_rate_presenter":
      return buildExtensionOutputConfig("delivery option presenter");
  }
}
function buildExtensionOutputConfig(humanKey, helpURL, additionalHelp) {
  return {
    humanKey,
    helpURL,
    additionalHelp
  };
}

const AppConfigurationSchema = schema.define.object({
  scopes: schema.define.string().default("")
});
const UIExtensionConfigurationSchema = schema.define.object({
  name: schema.define.string(),
  type: schema.define.enum(uiExtensions.types),
  metafields: schema.define.array(schema.define.object({
    namespace: schema.define.string(),
    key: schema.define.string()
  })).default([]),
  extensionPoints: schema.define.array(schema.define.string()).optional(),
  capabilities: schema.define.any().optional(),
  runtimeContext: schema.define.string().optional(),
  version: schema.define.string().optional(),
  configuration: schema.define.any().optional()
});
const FunctionExtensionConfigurationSchema = schema.define.object({
  name: schema.define.string(),
  type: schema.define.enum(functionExtensions.types),
  description: schema.define.string().default(""),
  build: schema.define.object({
    command: schema.define.string(),
    path: schema.define.string().optional()
  }),
  configurationUi: schema.define.boolean().optional().default(true),
  ui: schema.define.object({
    paths: schema.define.object({
      create: schema.define.string(),
      details: schema.define.string()
    }).optional()
  }).optional(),
  apiVersion: schema.define.string()
});
const ThemeExtensionConfigurationSchema = schema.define.object({
  name: schema.define.string(),
  type: schema.define.enum(themeExtensions.types)
});
const FunctionExtensionMetadataSchema = schema.define.object({
  schemaVersions: schema.define.object({}).catchall(schema.define.object({
    major: schema.define.number(),
    minor: schema.define.number()
  }))
});
var WebType = /* @__PURE__ */ ((WebType2) => {
  WebType2["Frontend"] = "frontend";
  WebType2["Backend"] = "backend";
  return WebType2;
})(WebType || {});
const WebConfigurationSchema = schema.define.object({
  type: schema.define.enum(["frontend" /* Frontend */, "backend" /* Backend */]),
  commands: schema.define.object({
    build: schema.define.string().optional(),
    dev: schema.define.string()
  })
});
class AppErrors {
  constructor() {
    this.errors = {};
  }
  addError(path2, message) {
    this.errors[path2] = message;
  }
  getError(path2) {
    return this.errors[path2];
  }
  isEmpty() {
    return Object.keys(this.errors).length === 0;
  }
  toJSON() {
    return Object.values(this.errors);
  }
}
class AppLoader {
  constructor({ directory, mode }) {
    this.appDirectory = "";
    this.configurationPath = "";
    this.errors = new AppErrors();
    this.mode = mode;
    this.directory = directory;
  }
  async loaded() {
    this.appDirectory = await this.findAppDirectory();
    const configurationPath = await this.getConfigurationPath();
    const configuration = await this.parseConfigurationFile(AppConfigurationSchema, configurationPath);
    const extensionsPath = path.join(this.appDirectory, `${blocks.extensions.directoryName}`);
    const dotenv2 = await this.loadDotEnv();
    const functions = await this.loadFunctions(extensionsPath);
    const uiExtensions2 = await this.loadUIExtensions(extensionsPath);
    const themeExtensions2 = await this.loadThemeExtensions(extensionsPath);
    const packageJSONPath = path.join(this.appDirectory, "package.json");
    const name = await dependency.getPackageName(packageJSONPath);
    const nodeDependencies = await dependency.getDependencies(packageJSONPath);
    const dependencyManager = await dependency.getDependencyManager(this.appDirectory);
    const app = {
      name,
      idEnvironmentVariableName: "SHOPIFY_API_KEY",
      directory: this.appDirectory,
      webs: await this.loadWebs(),
      configuration,
      configurationPath,
      dotenv: dotenv2,
      extensions: { ui: uiExtensions2, theme: themeExtensions2, function: functions },
      dependencyManager,
      nodeDependencies
    };
    if (!this.errors.isEmpty())
      app.errors = this.errors;
    return app;
  }
  async loadDotEnv() {
    let dotEnvFile;
    const dotEnvPath = path.join(this.appDirectory, dotEnvFileNames.production);
    if (await file.exists(dotEnvPath)) {
      dotEnvFile = await dotenv.read(dotEnvPath);
    }
    return dotEnvFile;
  }
  async findAppDirectory() {
    if (!await file.exists(this.directory)) {
      throw new error.Abort(output.content`Couldn't find directory ${output.token.path(this.directory)}`);
    }
    return path.dirname(await this.getConfigurationPath());
  }
  async getConfigurationPath() {
    if (this.configurationPath)
      return this.configurationPath;
    const configurationPath = await path.findUp(configurationFileNames.app, {
      cwd: this.directory,
      type: "file"
    });
    if (!configurationPath) {
      throw new error.Abort(output.content`Couldn't find the configuration file for ${output.token.path(this.directory)}, are you in an app directory?`);
    }
    this.configurationPath = configurationPath;
    return configurationPath;
  }
  async loadWebs() {
    const webTomlPaths = await path.glob(path.join(this.appDirectory, `web/**/${configurationFileNames.web}`));
    const webs = await Promise.all(webTomlPaths.map((path2) => this.loadWeb(path2)));
    return webs;
  }
  async loadWeb(WebConfigurationFile) {
    return {
      directory: path.dirname(WebConfigurationFile),
      configuration: await this.parseConfigurationFile(WebConfigurationSchema, WebConfigurationFile)
    };
  }
  async loadConfigurationFile(filepath, decode = toml.decode) {
    if (!await file.exists(filepath)) {
      return this.abortOrReport(output.content`Couldn't find the configuration file at ${output.token.path(filepath)}`, "", filepath);
    }
    const configurationContent = await file.read(filepath);
    let configuration;
    try {
      configuration = decode(configurationContent);
    } catch (err) {
      if (err.line && err.pos && err.col) {
        return this.abortOrReport(output.content`Fix the following error in ${output.token.path(filepath)}:\n${err.message}`, null, filepath);
      } else {
        throw err;
      }
    }
    return {
      ...Object.fromEntries(Object.entries(configuration).map((kv) => [string.camelize(kv[0]), kv[1]]))
    };
  }
  async parseConfigurationFile(schema2, filepath, decode = toml.decode) {
    const fallbackOutput = {};
    const configurationObject = await this.loadConfigurationFile(filepath, decode);
    if (!configurationObject)
      return fallbackOutput;
    const parseResult = schema2.safeParse(configurationObject);
    if (!parseResult.success) {
      const formattedError = JSON.stringify(parseResult.error.issues, null, 2);
      return this.abortOrReport(output.content`Fix a schema error in ${output.token.path(filepath)}:\n${formattedError}`, fallbackOutput, filepath);
    }
    return parseResult.data;
  }
  async loadUIExtensions(extensionsPath) {
    const extensionConfigPaths = path.join(extensionsPath, `*/${configurationFileNames.extension.ui}`);
    const configPaths = await path.glob(extensionConfigPaths);
    const extensions = configPaths.map(async (configurationPath) => {
      const directory = path.dirname(configurationPath);
      const configuration = await this.parseConfigurationFile(UIExtensionConfigurationSchema, configurationPath);
      const entrySourceFilePath = (await Promise.all(["index"].flatMap((name) => [`${name}.js`, `${name}.jsx`, `${name}.ts`, `${name}.tsx`]).flatMap((fileName) => [`src/${fileName}`, `${fileName}`]).map((relativePath) => path.join(directory, relativePath)).map(async (sourcePath) => await file.exists(sourcePath) ? sourcePath : void 0))).find((sourcePath) => sourcePath !== void 0);
      if (!entrySourceFilePath) {
        this.abortOrReport(output.content`Couldn't find an index.{js,jsx,ts,tsx} file in the directories ${output.token.path(directory)} or ${output.token.path(path.join(directory, "src"))}`, void 0, directory);
      }
      return {
        idEnvironmentVariableName: `SHOPIFY_${string.constantize(path.basename(directory))}_ID`,
        directory,
        configuration,
        configurationPath,
        type: configuration.type,
        graphQLType: extensionGraphqlId(configuration.type),
        buildDirectory: path.join(directory, "dist"),
        entrySourceFilePath: entrySourceFilePath ?? "",
        localIdentifier: path.basename(directory),
        devUUID: `dev-${id.generateRandomUUID()}`
      };
    });
    return Promise.all(extensions);
  }
  async loadFunctions(extensionsPath) {
    const functionConfigPaths = await path.join(extensionsPath, `*/${configurationFileNames.extension.function}`);
    const configPaths = await path.glob(functionConfigPaths);
    const functions = configPaths.map(async (configurationPath) => {
      const directory = path.dirname(configurationPath);
      const configuration = await this.parseConfigurationFile(FunctionExtensionConfigurationSchema, configurationPath);
      const metadata = await this.parseConfigurationFile(FunctionExtensionMetadataSchema, path.join(directory, "metadata.json"), JSON.parse);
      return {
        directory,
        configuration,
        configurationPath,
        metadata,
        type: configuration.type,
        graphQLType: extensionGraphqlId(configuration.type),
        idEnvironmentVariableName: `SHOPIFY_${string.constantize(path.basename(directory))}_ID`,
        localIdentifier: path.basename(directory),
        buildWasmPath() {
          return configuration.build.path ? path.join(directory, configuration.build.path) : path.join(directory, "dist/index.wasm");
        },
        inputQueryPath() {
          return path.join(directory, "input.graphql");
        }
      };
    });
    return Promise.all(functions);
  }
  async loadThemeExtensions(extensionsPath) {
    const themeConfigPaths = await path.join(extensionsPath, `*/${configurationFileNames.extension.theme}`);
    const configPaths = await path.glob(themeConfigPaths);
    const themeExtensions2 = configPaths.map(async (configurationPath) => {
      const directory = path.dirname(configurationPath);
      const configuration = await this.parseConfigurationFile(ThemeExtensionConfigurationSchema, configurationPath);
      return {
        directory,
        configuration,
        configurationPath,
        type: configuration.type,
        graphQLType: extensionGraphqlId(configuration.type),
        idEnvironmentVariableName: `SHOPIFY_${string.constantize(path.basename(directory))}_ID`,
        localIdentifier: path.basename(directory)
      };
    });
    return Promise.all(themeExtensions2);
  }
  abortOrReport(errorMessage, fallback, configurationPath) {
    if (this.mode === "strict") {
      throw new error.Abort(errorMessage);
    } else {
      this.errors.addError(configurationPath, errorMessage);
      return fallback;
    }
  }
}
async function updateDependencies(app) {
  const nodeDependencies = await dependency.getDependencies(path.join(app.directory, "package.json"));
  return {
    ...app,
    nodeDependencies
  };
}
async function updateAppIdentifiers({ app, identifiers, command }, systemEnvironment = process.env) {
  let dotenvFile = app.dotenv;
  if (!dotenvFile) {
    dotenvFile = {
      path: path.join(app.directory, dotEnvFileNames.production),
      variables: {}
    };
  }
  const updatedVariables = { ...app.dotenv?.variables ?? {} };
  if (!systemEnvironment[app.idEnvironmentVariableName]) {
    updatedVariables[app.idEnvironmentVariableName] = identifiers.app;
  }
  Object.keys(identifiers.extensions).forEach((identifier) => {
    const envVariable = `SHOPIFY_${string.constantize(identifier)}_ID`;
    if (!systemEnvironment[envVariable]) {
      updatedVariables[envVariable] = identifiers.extensions[identifier];
    }
  });
  const write = JSON.stringify(dotenvFile.variables) !== JSON.stringify(updatedVariables) && command === "deploy";
  dotenvFile.variables = updatedVariables;
  if (write) {
    await dotenv.write(dotenvFile);
  }
  return {
    ...app,
    dotenv: dotenvFile
  };
}
function getAppIdentifiers({ app }, systemEnvironment = process.env) {
  const envVariables = {
    ...app.dotenv?.variables,
    ...systemEnvironment
  };
  const extensionsIdentifiers = {};
  const processExtension = (extension) => {
    if (Object.keys(envVariables).includes(extension.idEnvironmentVariableName)) {
      extensionsIdentifiers[extension.localIdentifier] = envVariables[extension.idEnvironmentVariableName];
    }
  };
  app.extensions.ui.forEach(processExtension);
  app.extensions.function.forEach(processExtension);
  app.extensions.theme.forEach(processExtension);
  return {
    app: envVariables[app.idEnvironmentVariableName],
    extensions: extensionsIdentifiers
  };
}
async function getUIExtensionRendererVersion(uiExtensionType, app) {
  const fullName = getUIExtensionRendererDependency(uiExtensionType)?.name.replace("-react", "");
  if (!fullName)
    return void 0;
  const dependencyName = fullName.split("/");
  const realPath = path.join("node_modules", dependencyName[0], dependencyName[1], "package.json");
  const packagePath = await path.findUp(realPath, { type: "file", cwd: app.directory });
  if (!packagePath)
    return "not_found";
  const packageContent = await dependency.packageJSONContents(packagePath);
  if (!packageContent.version)
    return "not_found";
  return { name: fullName, version: packageContent.version };
}
async function load(directory, mode = "strict") {
  const loader = new AppLoader({ directory, mode });
  return loader.loaded();
}
function hasExtensions(app) {
  return app.extensions.ui.length !== 0 || app.extensions.function.length !== 0 || app.extensions.theme.length !== 0;
}
const extensionGraphqlId = (type) => {
  switch (type) {
    case "product_subscription":
      return "SUBSCRIPTION_MANAGEMENT";
    case "checkout_ui_extension":
      return "CHECKOUT_UI_EXTENSION";
    case "checkout_post_purchase":
      return "CHECKOUT_POST_PURCHASE";
    case "pos_ui_extension":
      return "POS_UI_EXTENSION";
    case "theme":
      return "THEME_APP_EXTENSION";
    case "web_pixel_extension":
      return "WEB_PIXEL_EXTENSION";
    case "product_discounts":
    case "order_discounts":
    case "shipping_discounts":
    case "payment_methods":
    case "shipping_rate_presenter":
      return type;
  }
};

export { WebType as W, appFlags as a, getFunctionExtensionPointName as b, blocks as c, updateAppIdentifiers as d, environmentVariables as e, isFunctionExtensionType as f, getUIExtensionRendererVersion as g, hasExtensions as h, isUiExtensionType as i, isThemeExtensionType as j, extensionGraphqlId as k, load as l, getAppIdentifiers as m, getExtensionOutputConfig as n, uiExtensions as o, functionExtensions as p, configurationFileNames as q, uiExtensionTemplates as r, functionExtensionTemplates as s, themeExtensions as t, updateDependencies as u, versions as v, extensions as w, extensionTypeCategory as x, getUIExtensionRendererDependency as y, limitedExtensions as z };
//# sourceMappingURL=app-5df50971.js.map
