import { c as constants$1, A as Abort, f as fqdn$1, l as local, u as utilities, a as ansiColors, i as isTerminalInteractive, B as Bug, b as content, t as token, d as isTruthy, e as info, g as exists, h as AbortSilent, r as remove$3, j as exec, m as mkdir, k as captureOutput, w as write$1, n as cliKitPackageJson, o as debug$2, v as version$2, p as read$1, q as isDebug, s as analyticsDisabled, x as platformAndArch, y as isShopify, z as stringifyMessage, C as hasGit, D as username, E as moduleDirectory, F as open, G as warn, H as completed, I as isDirectory, J as hasExecutablePermissions, K as copy, L as chmod } from './local-d0094ffe.js';
export { c as constants, M as error, N as file, O as os, P as output, Q as path, R as system } from './local-d0094ffe.js';
import { AbortController, AbortSignal } from 'abort-controller';
import 'commondir';
import { relative, join, dirname, resolve } from 'pathe';
import url$1 from 'url';
import { findUp } from 'find-up';
import glob from 'fast-glob';
import { pathToFileURL } from 'node:url';
import 'env-paths';
import nodeFetch from 'node-fetch';
import FormData from 'form-data';
import enquirer from 'enquirer';
import 'is-interactive';
import 'node:os';
import inquirer from 'inquirer';
import { Listr } from 'listr2';
import { spawn } from 'child_process';
import { Writable } from 'node:stream';
import Conf from 'conf';
import latestVersion from 'latest-version';
import crypto, { randomUUID } from 'crypto';
import { request as request$2, ClientError, gql } from 'graphql-request';
import { ExtendableError } from 'ts-error';
import md5File from 'md5-file';
import { Flags } from '@oclif/core';
import { parse as parse$2, stringify } from 'envfile';
import Fastify__default from 'fastify';
import * as Fastify from 'fastify';
export { Fastify as fastify };
import git$1 from 'simple-git';
import Haikunator from 'haikunator';
import * as port$1 from 'get-port-please';
import { z } from 'zod';
import 'fs-extra';
import 'del';
import tempy from 'tempy';
import 'prettier';
import 'terminal-link';
import 'stacktracey';
import 'color-json';
import 'execa';
import 'node:process';
import { camelCase, paramCase, snakeCase, constantCase } from 'change-case';
import { Liquid } from 'liquidjs';
import * as toml$1 from '@iarna/toml';
import * as yaml$1 from 'js-yaml';
import 'source-map-support';

var abort = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Controller: AbortController,
  Signal: AbortSignal
});

var Environment = /* @__PURE__ */ ((Environment2) => {
  Environment2["Local"] = "local";
  Environment2["Production"] = "production";
  Environment2["Spin"] = "spin";
  return Environment2;
})(Environment || {});

function service(value) {
  if (value === "local") {
    return Environment.Local;
  } else if (value === "spin") {
    return Environment.Spin;
  } else {
    return Environment.Production;
  }
}
function partners$2(env = process.env) {
  return service(env[constants$1.environmentVariables.partnersEnv]);
}
function shopify$1(env = process.env) {
  return service(env[constants$1.environmentVariables.shopifyEnv]);
}
function identity$1(env = process.env) {
  return service(env[constants$1.environmentVariables.identityEnv]);
}

var service$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  partners: partners$2,
  shopify: shopify$1,
  identity: identity$1
});

const CouldntObtainPartnersSpinFQDNError = new Abort("Couldn't obtain the Spin FQDN for Partners when the CLI is not running from a Spin environment.");
const CouldntObtainIdentitySpinFQDNError = new Abort("Couldn't obtain the Spin FQDN for Identity when the CLI is not running from a Spin environment.");
const CouldntObtainShopifySpinFQDNError = new Abort("Couldn't obtain the Spin FQDN for Shopify when the CLI is not running from a Spin environment.");
const NotProvidedStoreFQDNError = new Abort("Couldn't obtain the Shopify FQDN because the store FQDN was not provided.");
async function partners$1() {
  const environment = partners$2();
  const productionFqdn = "partners.shopify.com";
  switch (environment) {
    case "local":
      return "partners.myshopify.io";
    case "spin":
      return `partners.${await fqdn$1()}`;
    default:
      return productionFqdn;
  }
}
async function identity() {
  const environment = identity$1();
  const productionFqdn = "accounts.shopify.com";
  switch (environment) {
    case "local":
      return "identity.myshopify.io";
    case "spin":
      return `identity.${await fqdn$1()}`;
    default:
      return productionFqdn;
  }
}
async function shopify(options = {}) {
  const environment = shopify$1();
  switch (environment) {
    case "local":
      return "shopify.myshopify.io";
    case "spin":
      return `identity.${await fqdn$1()}`;
    default:
      if (options.storeFqdn) {
        return options.storeFqdn;
      } else {
        throw NotProvidedStoreFQDNError;
      }
  }
}

var fqdn = /*#__PURE__*/Object.freeze({
  __proto__: null,
  CouldntObtainPartnersSpinFQDNError: CouldntObtainPartnersSpinFQDNError,
  CouldntObtainIdentitySpinFQDNError: CouldntObtainIdentitySpinFQDNError,
  CouldntObtainShopifySpinFQDNError: CouldntObtainShopifySpinFQDNError,
  NotProvidedStoreFQDNError: NotProvidedStoreFQDNError,
  partners: partners$1,
  identity: identity,
  shopify: shopify
});

var environment = /*#__PURE__*/Object.freeze({
  __proto__: null,
  local: local,
  service: service$1,
  fqdn: fqdn,
  utilities: utilities
});

async function fetch$2(url, init) {
  const response = await nodeFetch(url, init);
  return response;
}

function formData() {
  return new FormData();
}

var http = /*#__PURE__*/Object.freeze({
  __proto__: null,
  fetch: fetch$2,
  formData: formData
});

class AutoComplete extends enquirer.AutoComplete {
  constructor(options) {
    const originalResult = options.result;
    options.result = (value) => {
      const answer = this.focused.value || this.focused.name || value;
      if (originalResult) {
        return originalResult(answer);
      }
      return answer;
    };
    super(options);
    this.styles.primary = ansiColors.exports.magenta;
    this.styles.em = ansiColors.exports.magenta;
  }
  pointer(_choice, i) {
    const color = this.styles.primary;
    const showPointer = !this.state.multiple && this.state.index === i;
    return showPointer ? color(">") : " ";
  }
  prefix(_state) {
    const color = this.styles.primary.bold;
    return this.state.status === "submitted" ? color("\u2714") : color("?");
  }
  format() {
    if (!this.focused)
      return this.input;
    if (this.options.multiple && this.state.submitted) {
      return this.selected.map((ch) => this.styles.primary(ch.message)).join(", ");
    }
    if (this.state.submitted) {
      this.value = this.focused.value;
      this.input = this.focused.value;
      return this.styles.primary(this.focused.name);
    }
    return this.input;
  }
}

class Input extends enquirer.StringPrompt {
  constructor(options) {
    super(options);
    this.styles.primary = ansiColors.exports.magenta;
    this.styles.submitted = ansiColors.exports.magenta;
    this.styles.danger = ansiColors.exports.red;
    this.symbols.pointer = "!";
  }
  prefix(_state) {
    const color = this.styles.primary.bold;
    return this.state.status === "submitted" ? color("\u2714") : color("?");
  }
  async render() {
    const size = this.state.size;
    const prefix = await this.prefix();
    const separator = await this.separator();
    const message = await this.message();
    const color = this.styles.primary;
    let prompt = [prefix, message].filter(Boolean).join(" ");
    this.state.prompt = prompt;
    const output = this.type === "password" ? await this.formatPassword() : await this.format();
    const help = await this.error() || await this.hint();
    const underline = "\u2594".repeat(Math.max(color.unstyle(output).length - 10, 30));
    if (this.state.submitted) {
      prompt += ` ${separator} ${output}`;
    } else {
      prompt += `
${color(">")} ${output}
  ${color(underline)}`;
      if (help && !prompt.includes(help))
        prompt += ` ${help}`;
    }
    this.clear(size);
    this.write([prompt].filter(Boolean).join("\n"));
    this.restore();
  }
  formatPassword() {
    if (!this.keypressed)
      return "";
    const color = this.state.submitted ? this.styles.primary : this.styles.muted;
    return color(this.symbols.asterisk.repeat(this.input.length));
  }
}

class Select extends enquirer.Select {
  constructor(options) {
    const originalResult = options.result;
    options.result = (value) => {
      const answer = this.focused.value || this.focused.name || value;
      if (originalResult) {
        return originalResult(answer);
      }
      return answer;
    };
    super(options);
    this.styles.primary = ansiColors.exports.magenta;
    this.styles.em = ansiColors.exports.magenta;
  }
  pointer(_choice, i) {
    const color = this.styles.primary;
    const showPointer = !this.state.multiple && this.state.index === i;
    return showPointer ? color(">") : " ";
  }
  prefix(_state) {
    const color = this.styles.primary.bold;
    return this.state.status === "submitted" ? color("\u2714") : color("?");
  }
}

const prompt = async (questions, debugForceInquirer = false) => {
  if (!isTerminalInteractive() && questions.length !== 0) {
    throw new Bug(content`
The CLI prompted in a non-interactive terminal with the following questions:
${token.json(questions)}
    `);
  }
  if (debugForceInquirer || isTruthy(process.env.SHOPIFY_USE_INQUIRER)) {
    const results = [];
    for (const question of questions) {
      if (question.preface) {
        info(question.preface);
      }
      const questionName = question.name;
      const answer = (await inquirer.prompt([convertQuestionForInquirer(question)]))[questionName];
      results.push([questionName, answer]);
    }
    return Object.fromEntries(results);
  } else {
    const mappedQuestions = questions.map(mapper);
    const value = {};
    for (const question of mappedQuestions) {
      if (question.preface) {
        info(question.preface);
      }
      value[question.name] = await question.run();
    }
    return value;
  }
};
async function nonEmptyDirectoryPrompt(directory) {
  if (await exists(directory)) {
    const options = [
      { name: "No, don\u2019t delete the files", value: "abort" },
      { name: "Yes, delete the files", value: "overwrite" }
    ];
    const relativeDirectory = relative(process.cwd(), directory);
    const questions = {
      type: "select",
      name: "value",
      message: `${relativeDirectory} is not an empty directory. Do you want to delete the existing files and continue?`,
      choices: options
    };
    const choice = await prompt([questions]);
    if (choice.value === "abort") {
      throw new AbortSilent();
    }
    remove$3(directory);
  }
}
const keypress = async () => {
  process.stdin.setRawMode(true);
  return new Promise((resolve) => process.stdin.once("data", () => {
    process.stdin.setRawMode(false);
    resolve();
  }));
};
function convertQuestionForInquirer(question) {
  switch (question.type) {
    case "input":
    case "password":
      return question;
    case "select":
    case "autocomplete":
      return {
        ...question,
        type: "list"
      };
  }
}
function mapper(question) {
  switch (question.type) {
    case "input":
    case "password":
      return new Input(question);
    case "select":
      return new Select(question);
    case "autocomplete":
      return new AutoComplete(question);
    default:
      return void 0;
  }
}

var ui = /*#__PURE__*/Object.freeze({
  __proto__: null,
  prompt: prompt,
  nonEmptyDirectoryPrompt: nonEmptyDirectoryPrompt,
  keypress: keypress,
  Listr: Listr
});

const debug$1 = (
  typeof process === 'object' &&
  process.env &&
  process.env.NODE_DEBUG &&
  /\bsemver\b/i.test(process.env.NODE_DEBUG)
) ? (...args) => console.error('SEMVER', ...args)
  : () => {};

var debug_1 = debug$1;

// Note: this is the semver.org version of the spec that it implements
// Not necessarily the package version of this code.
const SEMVER_SPEC_VERSION = '2.0.0';

const MAX_LENGTH$2 = 256;
const MAX_SAFE_INTEGER$1 = Number.MAX_SAFE_INTEGER ||
/* istanbul ignore next */ 9007199254740991;

// Max safe segment length for coercion.
const MAX_SAFE_COMPONENT_LENGTH = 16;

var constants = {
  SEMVER_SPEC_VERSION,
  MAX_LENGTH: MAX_LENGTH$2,
  MAX_SAFE_INTEGER: MAX_SAFE_INTEGER$1,
  MAX_SAFE_COMPONENT_LENGTH,
};

var re$3 = {exports: {}};

(function (module, exports) {
	const { MAX_SAFE_COMPONENT_LENGTH } = constants;
	const debug = debug_1;
	exports = module.exports = {};

	// The actual regexps go on exports.re
	const re = exports.re = [];
	const src = exports.src = [];
	const t = exports.t = {};
	let R = 0;

	const createToken = (name, value, isGlobal) => {
	  const index = R++;
	  debug(name, index, value);
	  t[name] = index;
	  src[index] = value;
	  re[index] = new RegExp(value, isGlobal ? 'g' : undefined);
	};

	// The following Regular Expressions can be used for tokenizing,
	// validating, and parsing SemVer version strings.

	// ## Numeric Identifier
	// A single `0`, or a non-zero digit followed by zero or more digits.

	createToken('NUMERICIDENTIFIER', '0|[1-9]\\d*');
	createToken('NUMERICIDENTIFIERLOOSE', '[0-9]+');

	// ## Non-numeric Identifier
	// Zero or more digits, followed by a letter or hyphen, and then zero or
	// more letters, digits, or hyphens.

	createToken('NONNUMERICIDENTIFIER', '\\d*[a-zA-Z-][a-zA-Z0-9-]*');

	// ## Main Version
	// Three dot-separated numeric identifiers.

	createToken('MAINVERSION', `(${src[t.NUMERICIDENTIFIER]})\\.` +
	                   `(${src[t.NUMERICIDENTIFIER]})\\.` +
	                   `(${src[t.NUMERICIDENTIFIER]})`);

	createToken('MAINVERSIONLOOSE', `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` +
	                        `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` +
	                        `(${src[t.NUMERICIDENTIFIERLOOSE]})`);

	// ## Pre-release Version Identifier
	// A numeric identifier, or a non-numeric identifier.

	createToken('PRERELEASEIDENTIFIER', `(?:${src[t.NUMERICIDENTIFIER]
	}|${src[t.NONNUMERICIDENTIFIER]})`);

	createToken('PRERELEASEIDENTIFIERLOOSE', `(?:${src[t.NUMERICIDENTIFIERLOOSE]
	}|${src[t.NONNUMERICIDENTIFIER]})`);

	// ## Pre-release Version
	// Hyphen, followed by one or more dot-separated pre-release version
	// identifiers.

	createToken('PRERELEASE', `(?:-(${src[t.PRERELEASEIDENTIFIER]
	}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);

	createToken('PRERELEASELOOSE', `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]
	}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);

	// ## Build Metadata Identifier
	// Any combination of digits, letters, or hyphens.

	createToken('BUILDIDENTIFIER', '[0-9A-Za-z-]+');

	// ## Build Metadata
	// Plus sign, followed by one or more period-separated build metadata
	// identifiers.

	createToken('BUILD', `(?:\\+(${src[t.BUILDIDENTIFIER]
	}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);

	// ## Full Version String
	// A main version, followed optionally by a pre-release version and
	// build metadata.

	// Note that the only major, minor, patch, and pre-release sections of
	// the version string are capturing groups.  The build metadata is not a
	// capturing group, because it should not ever be used in version
	// comparison.

	createToken('FULLPLAIN', `v?${src[t.MAINVERSION]
	}${src[t.PRERELEASE]}?${
	  src[t.BUILD]}?`);

	createToken('FULL', `^${src[t.FULLPLAIN]}$`);

	// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
	// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
	// common in the npm registry.
	createToken('LOOSEPLAIN', `[v=\\s]*${src[t.MAINVERSIONLOOSE]
	}${src[t.PRERELEASELOOSE]}?${
	  src[t.BUILD]}?`);

	createToken('LOOSE', `^${src[t.LOOSEPLAIN]}$`);

	createToken('GTLT', '((?:<|>)?=?)');

	// Something like "2.*" or "1.2.x".
	// Note that "x.x" is a valid xRange identifer, meaning "any version"
	// Only the first item is strictly required.
	createToken('XRANGEIDENTIFIERLOOSE', `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
	createToken('XRANGEIDENTIFIER', `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);

	createToken('XRANGEPLAIN', `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})` +
	                   `(?:\\.(${src[t.XRANGEIDENTIFIER]})` +
	                   `(?:\\.(${src[t.XRANGEIDENTIFIER]})` +
	                   `(?:${src[t.PRERELEASE]})?${
	                     src[t.BUILD]}?` +
	                   `)?)?`);

	createToken('XRANGEPLAINLOOSE', `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})` +
	                        `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +
	                        `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +
	                        `(?:${src[t.PRERELEASELOOSE]})?${
	                          src[t.BUILD]}?` +
	                        `)?)?`);

	createToken('XRANGE', `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
	createToken('XRANGELOOSE', `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);

	// Coercion.
	// Extract anything that could conceivably be a part of a valid semver
	createToken('COERCE', `${'(^|[^\\d])' +
	              '(\\d{1,'}${MAX_SAFE_COMPONENT_LENGTH}})` +
	              `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` +
	              `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` +
	              `(?:$|[^\\d])`);
	createToken('COERCERTL', src[t.COERCE], true);

	// Tilde ranges.
	// Meaning is "reasonably at or greater than"
	createToken('LONETILDE', '(?:~>?)');

	createToken('TILDETRIM', `(\\s*)${src[t.LONETILDE]}\\s+`, true);
	exports.tildeTrimReplace = '$1~';

	createToken('TILDE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
	createToken('TILDELOOSE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);

	// Caret ranges.
	// Meaning is "at least and backwards compatible with"
	createToken('LONECARET', '(?:\\^)');

	createToken('CARETTRIM', `(\\s*)${src[t.LONECARET]}\\s+`, true);
	exports.caretTrimReplace = '$1^';

	createToken('CARET', `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
	createToken('CARETLOOSE', `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);

	// A simple gt/lt/eq thing, or just "" to indicate "any version"
	createToken('COMPARATORLOOSE', `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
	createToken('COMPARATOR', `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);

	// An expression to strip any whitespace between the gtlt and the thing
	// it modifies, so that `> 1.2.3` ==> `>1.2.3`
	createToken('COMPARATORTRIM', `(\\s*)${src[t.GTLT]
	}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
	exports.comparatorTrimReplace = '$1$2$3';

	// Something like `1.2.3 - 1.2.4`
	// Note that these all use the loose form, because they'll be
	// checked against either the strict or loose comparator form
	// later.
	createToken('HYPHENRANGE', `^\\s*(${src[t.XRANGEPLAIN]})` +
	                   `\\s+-\\s+` +
	                   `(${src[t.XRANGEPLAIN]})` +
	                   `\\s*$`);

	createToken('HYPHENRANGELOOSE', `^\\s*(${src[t.XRANGEPLAINLOOSE]})` +
	                        `\\s+-\\s+` +
	                        `(${src[t.XRANGEPLAINLOOSE]})` +
	                        `\\s*$`);

	// Star ranges basically just allow anything at all.
	createToken('STAR', '(<|>)?=?\\s*\\*');
	// >=0.0.0 is like a star
	createToken('GTE0', '^\\s*>=\\s*0\\.0\\.0\\s*$');
	createToken('GTE0PRE', '^\\s*>=\\s*0\\.0\\.0-0\\s*$');
} (re$3, re$3.exports));

// parse out just the options we care about so we always get a consistent
// obj with keys in a consistent order.
const opts = ['includePrerelease', 'loose', 'rtl'];
const parseOptions$2 = options =>
  !options ? {}
  : typeof options !== 'object' ? { loose: true }
  : opts.filter(k => options[k]).reduce((o, k) => {
    o[k] = true;
    return o
  }, {});
var parseOptions_1 = parseOptions$2;

const numeric = /^[0-9]+$/;
const compareIdentifiers$1 = (a, b) => {
  const anum = numeric.test(a);
  const bnum = numeric.test(b);

  if (anum && bnum) {
    a = +a;
    b = +b;
  }

  return a === b ? 0
    : (anum && !bnum) ? -1
    : (bnum && !anum) ? 1
    : a < b ? -1
    : 1
};

const rcompareIdentifiers = (a, b) => compareIdentifiers$1(b, a);

var identifiers = {
  compareIdentifiers: compareIdentifiers$1,
  rcompareIdentifiers,
};

const debug = debug_1;
const { MAX_LENGTH: MAX_LENGTH$1, MAX_SAFE_INTEGER } = constants;
const { re: re$2, t: t$2 } = re$3.exports;

const parseOptions$1 = parseOptions_1;
const { compareIdentifiers } = identifiers;
class SemVer$2 {
  constructor (version, options) {
    options = parseOptions$1(options);

    if (version instanceof SemVer$2) {
      if (version.loose === !!options.loose &&
          version.includePrerelease === !!options.includePrerelease) {
        return version
      } else {
        version = version.version;
      }
    } else if (typeof version !== 'string') {
      throw new TypeError(`Invalid Version: ${version}`)
    }

    if (version.length > MAX_LENGTH$1) {
      throw new TypeError(
        `version is longer than ${MAX_LENGTH$1} characters`
      )
    }

    debug('SemVer', version, options);
    this.options = options;
    this.loose = !!options.loose;
    // this isn't actually relevant for versions, but keep it so that we
    // don't run into trouble passing this.options around.
    this.includePrerelease = !!options.includePrerelease;

    const m = version.trim().match(options.loose ? re$2[t$2.LOOSE] : re$2[t$2.FULL]);

    if (!m) {
      throw new TypeError(`Invalid Version: ${version}`)
    }

    this.raw = version;

    // these are actually numbers
    this.major = +m[1];
    this.minor = +m[2];
    this.patch = +m[3];

    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
      throw new TypeError('Invalid major version')
    }

    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
      throw new TypeError('Invalid minor version')
    }

    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
      throw new TypeError('Invalid patch version')
    }

    // numberify any prerelease numeric ids
    if (!m[4]) {
      this.prerelease = [];
    } else {
      this.prerelease = m[4].split('.').map((id) => {
        if (/^[0-9]+$/.test(id)) {
          const num = +id;
          if (num >= 0 && num < MAX_SAFE_INTEGER) {
            return num
          }
        }
        return id
      });
    }

    this.build = m[5] ? m[5].split('.') : [];
    this.format();
  }

  format () {
    this.version = `${this.major}.${this.minor}.${this.patch}`;
    if (this.prerelease.length) {
      this.version += `-${this.prerelease.join('.')}`;
    }
    return this.version
  }

  toString () {
    return this.version
  }

  compare (other) {
    debug('SemVer.compare', this.version, this.options, other);
    if (!(other instanceof SemVer$2)) {
      if (typeof other === 'string' && other === this.version) {
        return 0
      }
      other = new SemVer$2(other, this.options);
    }

    if (other.version === this.version) {
      return 0
    }

    return this.compareMain(other) || this.comparePre(other)
  }

  compareMain (other) {
    if (!(other instanceof SemVer$2)) {
      other = new SemVer$2(other, this.options);
    }

    return (
      compareIdentifiers(this.major, other.major) ||
      compareIdentifiers(this.minor, other.minor) ||
      compareIdentifiers(this.patch, other.patch)
    )
  }

  comparePre (other) {
    if (!(other instanceof SemVer$2)) {
      other = new SemVer$2(other, this.options);
    }

    // NOT having a prerelease is > having one
    if (this.prerelease.length && !other.prerelease.length) {
      return -1
    } else if (!this.prerelease.length && other.prerelease.length) {
      return 1
    } else if (!this.prerelease.length && !other.prerelease.length) {
      return 0
    }

    let i = 0;
    do {
      const a = this.prerelease[i];
      const b = other.prerelease[i];
      debug('prerelease compare', i, a, b);
      if (a === undefined && b === undefined) {
        return 0
      } else if (b === undefined) {
        return 1
      } else if (a === undefined) {
        return -1
      } else if (a === b) {
        continue
      } else {
        return compareIdentifiers(a, b)
      }
    } while (++i)
  }

  compareBuild (other) {
    if (!(other instanceof SemVer$2)) {
      other = new SemVer$2(other, this.options);
    }

    let i = 0;
    do {
      const a = this.build[i];
      const b = other.build[i];
      debug('prerelease compare', i, a, b);
      if (a === undefined && b === undefined) {
        return 0
      } else if (b === undefined) {
        return 1
      } else if (a === undefined) {
        return -1
      } else if (a === b) {
        continue
      } else {
        return compareIdentifiers(a, b)
      }
    } while (++i)
  }

  // preminor will bump the version up to the next minor release, and immediately
  // down to pre-release. premajor and prepatch work the same way.
  inc (release, identifier) {
    switch (release) {
      case 'premajor':
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor = 0;
        this.major++;
        this.inc('pre', identifier);
        break
      case 'preminor':
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor++;
        this.inc('pre', identifier);
        break
      case 'prepatch':
        // If this is already a prerelease, it will bump to the next version
        // drop any prereleases that might already exist, since they are not
        // relevant at this point.
        this.prerelease.length = 0;
        this.inc('patch', identifier);
        this.inc('pre', identifier);
        break
      // If the input is a non-prerelease version, this acts the same as
      // prepatch.
      case 'prerelease':
        if (this.prerelease.length === 0) {
          this.inc('patch', identifier);
        }
        this.inc('pre', identifier);
        break

      case 'major':
        // If this is a pre-major version, bump up to the same major version.
        // Otherwise increment major.
        // 1.0.0-5 bumps to 1.0.0
        // 1.1.0 bumps to 2.0.0
        if (
          this.minor !== 0 ||
          this.patch !== 0 ||
          this.prerelease.length === 0
        ) {
          this.major++;
        }
        this.minor = 0;
        this.patch = 0;
        this.prerelease = [];
        break
      case 'minor':
        // If this is a pre-minor version, bump up to the same minor version.
        // Otherwise increment minor.
        // 1.2.0-5 bumps to 1.2.0
        // 1.2.1 bumps to 1.3.0
        if (this.patch !== 0 || this.prerelease.length === 0) {
          this.minor++;
        }
        this.patch = 0;
        this.prerelease = [];
        break
      case 'patch':
        // If this is not a pre-release version, it will increment the patch.
        // If it is a pre-release it will bump up to the same patch version.
        // 1.2.0-5 patches to 1.2.0
        // 1.2.0 patches to 1.2.1
        if (this.prerelease.length === 0) {
          this.patch++;
        }
        this.prerelease = [];
        break
      // This probably shouldn't be used publicly.
      // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
      case 'pre':
        if (this.prerelease.length === 0) {
          this.prerelease = [0];
        } else {
          let i = this.prerelease.length;
          while (--i >= 0) {
            if (typeof this.prerelease[i] === 'number') {
              this.prerelease[i]++;
              i = -2;
            }
          }
          if (i === -1) {
            // didn't increment anything
            this.prerelease.push(0);
          }
        }
        if (identifier) {
          // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
          // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
          if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
            if (isNaN(this.prerelease[1])) {
              this.prerelease = [identifier, 0];
            }
          } else {
            this.prerelease = [identifier, 0];
          }
        }
        break

      default:
        throw new Error(`invalid increment argument: ${release}`)
    }
    this.format();
    this.raw = this.version;
    return this
  }
}

var semver$1 = SemVer$2;

const { MAX_LENGTH } = constants;
const { re: re$1, t: t$1 } = re$3.exports;
const SemVer$1 = semver$1;

const parseOptions = parseOptions_1;
const parse$1 = (version, options) => {
  options = parseOptions(options);

  if (version instanceof SemVer$1) {
    return version
  }

  if (typeof version !== 'string') {
    return null
  }

  if (version.length > MAX_LENGTH) {
    return null
  }

  const r = options.loose ? re$1[t$1.LOOSE] : re$1[t$1.FULL];
  if (!r.test(version)) {
    return null
  }

  try {
    return new SemVer$1(version, options)
  } catch (er) {
    return null
  }
};

var parse_1 = parse$1;

const SemVer = semver$1;
const parse = parse_1;
const { re, t } = re$3.exports;

const coerce = (version, options) => {
  if (version instanceof SemVer) {
    return version
  }

  if (typeof version === 'number') {
    version = String(version);
  }

  if (typeof version !== 'string') {
    return null
  }

  options = options || {};

  let match = null;
  if (!options.rtl) {
    match = version.match(re[t.COERCE]);
  } else {
    // Find the right-most coercible string that does not share
    // a terminus with a more left-ward coercible string.
    // Eg, '1.2.3.4' wants to coerce '2.3.4', not '3.4' or '4'
    //
    // Walk through the string checking with a /g regexp
    // Manually set the index so as to pick up overlapping matches.
    // Stop when we get a match that ends at the string end, since no
    // coercible string can be more right-ward without the same terminus.
    let next;
    while ((next = re[t.COERCERTL].exec(version)) &&
        (!match || match.index + match[0].length !== version.length)
    ) {
      if (!match ||
            next.index + next[0].length !== match.index + match[0].length) {
        match = next;
      }
      re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
    }
    // leave it in a clean state
    re[t.COERCERTL].lastIndex = -1;
  }

  if (match === null) {
    return null
  }

  return parse(`${match[2]}.${match[3] || '0'}.${match[4] || '0'}`, options)
};
var coerce_1 = coerce;

var semver = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Version: semver$1,
  coerce: coerce_1
});

const RubyCLIVersion = "2.16.0";
const ThemeCheckVersion = "1.10.2";
const MinBundlerVersion = "2.3.8";
const MinRubyVersion = "2.3.0";
const MinRubyGemVersion = "2.5.0";
async function execCLI(args, adminSession) {
  await installCLIDependencies();
  const env = {
    ...process.env,
    SHOPIFY_CLI_ADMIN_AUTH_TOKEN: adminSession?.token,
    SHOPIFY_CLI_STORE: adminSession?.storeFqdn
  };
  spawn("bundle", ["exec", "shopify"].concat(args), {
    stdio: "inherit",
    cwd: shopifyCLIDirectory(),
    shell: true,
    env
  });
}
async function execThemeCheckCLI({
  directories,
  args,
  stdout,
  stderr
}) {
  await installThemeCheckCLIDependencies(stdout);
  const processes = directories.map(async (directory) => {
    const files = await glob(join(directory, "/**/*"));
    const fileCount = files.filter((file2) => !file2.match(/\.toml$/)).length;
    if (fileCount === 0)
      return;
    const customStderr = new Writable({
      write(chunk, ...args2) {
        if (chunk.toString("ascii").match(/^Checking/)) {
          stdout.write(chunk, ...args2);
        } else {
          stderr.write(chunk, ...args2);
        }
      }
    });
    await exec("bundle", ["exec", "theme-check"].concat([directory, ...args || []]), {
      stdout,
      stderr: customStderr,
      cwd: themeCheckDirectory()
    });
  });
  return Promise.all(processes);
}
async function installThemeCheckCLIDependencies(stdout) {
  const exists$1 = await exists(themeCheckDirectory());
  if (!exists$1)
    stdout.write("Installing theme dependencies...");
  const list = new Listr([
    {
      title: "Installing theme dependencies",
      task: async () => {
        await validateRubyEnv();
        await createThemeCheckCLIWorkingDirectory();
        await createThemeCheckGemfile();
        await bundleInstallThemeCheck();
      }
    }
  ], { renderer: "silent" });
  await list.run();
  if (!exists$1)
    stdout.write("Installed theme dependencies!");
}
async function installCLIDependencies() {
  const exists$1 = await exists(shopifyCLIDirectory());
  const renderer = exists$1 ? "silent" : "default";
  const list = new Listr([
    {
      title: "Installing theme dependencies",
      task: async () => {
        await validateRubyEnv();
        await createShopifyCLIWorkingDirectory();
        await createShopifyCLIGemfile();
        await bundleInstallShopifyCLI();
      }
    }
  ], { renderer });
  await list.run();
}
async function validateRubyEnv() {
  await validateRuby();
  await validateRubyGems();
  await validateBundler();
}
async function validateRuby() {
  let version2;
  try {
    const stdout = await captureOutput("ruby", ["-v"]);
    version2 = coerce_1(stdout);
  } catch {
    throw new Abort("Ruby environment not found", `Make sure you have Ruby installed on your system: ${content`${token.link("", "https://www.ruby-lang.org/en/documentation/installation/")}`.value}`);
  }
  const isValid = version2?.compare(MinRubyVersion);
  if (isValid === -1 || isValid === void 0) {
    throw new Abort(`Ruby version ${content`${token.yellow(version2.raw)}`.value} is not supported`, `Make sure you have at least Ruby ${content`${token.yellow(MinRubyVersion)}`.value} installed on your system: ${content`${token.link("", "https://www.ruby-lang.org/en/documentation/installation/")}`.value}`);
  }
}
async function validateRubyGems() {
  const stdout = await captureOutput("gem", ["-v"]);
  const version2 = coerce_1(stdout);
  const isValid = version2?.compare(MinRubyGemVersion);
  if (isValid === -1 || isValid === void 0) {
    throw new Abort(`RubyGems version ${content`${token.yellow(version2.raw)}`.value} is not supported`, `To update to the latest version of RubyGems, run ${content`${token.genericShellCommand("gem update --system")}`.value}`);
  }
}
async function validateBundler() {
  let version2;
  try {
    const stdout = await captureOutput("bundler", ["-v"]);
    version2 = coerce_1(stdout);
  } catch {
    throw new Abort("Bundler not found", `To install the latest version of Bundler, run ${content`${token.genericShellCommand("gem install bundler")}`.value}`);
  }
  const isValid = version2?.compare(MinBundlerVersion);
  if (isValid === -1 || isValid === void 0) {
    throw new Abort(`Bundler version ${content`${token.yellow(version2.raw)}`.value} is not supported`, `To update to the latest version of Bundler, run ${content`${token.genericShellCommand("gem install bundler")}`.value}`);
  }
}
function createShopifyCLIWorkingDirectory() {
  return mkdir(shopifyCLIDirectory());
}
function createThemeCheckCLIWorkingDirectory() {
  return mkdir(themeCheckDirectory());
}
async function createShopifyCLIGemfile() {
  const gemPath = join(shopifyCLIDirectory(), "Gemfile");
  await write$1(gemPath, `source 'https://rubygems.org'
gem 'shopify-cli', '${RubyCLIVersion}'`);
}
async function createThemeCheckGemfile() {
  const gemPath = join(themeCheckDirectory(), "Gemfile");
  await write$1(gemPath, `source 'https://rubygems.org'
gem 'theme-check', '${ThemeCheckVersion}'`);
}
async function bundleInstallShopifyCLI() {
  await exec("bundle", ["config", "set", "--local", "path", shopifyCLIDirectory()], { cwd: shopifyCLIDirectory() });
  await exec("bundle", ["install"], { cwd: shopifyCLIDirectory() });
}
async function bundleInstallThemeCheck() {
  await exec("bundle", ["config", "set", "--local", "path", themeCheckDirectory()], { cwd: themeCheckDirectory() });
  await exec("bundle", ["install"], { cwd: themeCheckDirectory() });
}
function shopifyCLIDirectory() {
  return join(constants$1.paths.directories.cache.vendor.path(), "ruby-cli", RubyCLIVersion);
}
function themeCheckDirectory() {
  return join(constants$1.paths.directories.cache.vendor.path(), "theme-check", ThemeCheckVersion);
}
async function version$1() {
  const parseOutput = (version2) => version2.match(/ruby (\d+\.\d+\.\d+)/)?.[1];
  return captureOutput("ruby", ["-v"]).then(parseOutput).catch(() => void 0);
}

var ruby = /*#__PURE__*/Object.freeze({
  __proto__: null,
  execCLI: execCLI,
  execThemeCheckCLI: execThemeCheckCLI,
  version: version$1
});

const migrations = {};
const schema$1 = {
  appInfo: {
    type: "array",
    items: {
      type: "object",
      properties: {
        appId: {
          type: "string"
        },
        orgId: {
          type: "string"
        },
        storeFqdn: {
          type: "string"
        }
      }
    }
  }
};
function createConf(projectName = "shopify-cli-kit") {
  return new Conf({
    schema: schema$1,
    migrations,
    projectName,
    projectVersion: cliKitPackageJson.version
  });
}
const cliKit = createConf();
function remove$2() {
  cliKit.clear();
}
function getAppInfo(directory, localConf = cliKit) {
  debug$2(content`Reading cached app information for directory ${token.path(directory)}...`);
  const apps = localConf.get("appInfo") ?? [];
  return apps.find((app) => app.directory === directory);
}
function setAppInfo(options, localConf = cliKit) {
  debug$2(content`Storing app information for directory ${token.path(options.directory)}:
${token.json(options)}
`);
  const apps = localConf.get("appInfo") ?? [];
  const index = apps.findIndex((saved) => saved.directory === options.directory);
  if (index === -1) {
    apps.push(options);
  } else {
    const app = apps[index];
    apps[index] = {
      appId: options.appId,
      directory: options.directory,
      title: options.title ?? app.title,
      storeFqdn: options.storeFqdn ?? app.storeFqdn,
      orgId: options.orgId ?? app.orgId
    };
  }
  localConf.set("appInfo", apps);
}
function clearAppInfo(directory, localConf = cliKit) {
  debug$2(content`Clearing app information for directory ${token.path(directory)}...`);
  const apps = localConf.get("appInfo") ?? [];
  const index = apps.findIndex((saved) => saved.directory === directory);
  if (index !== -1) {
    apps.splice(index, 1);
  }
  localConf.set("appInfo", apps);
}
function getTheme(localConf = cliKit) {
  debug$2(content`Getting theme store...`);
  return localConf.get("themeStore");
}
function setTheme(store, localConf = cliKit) {
  debug$2(content`Setting theme store...`);
  localConf.set("themeStore", store);
}
function getSession(localConf = cliKit) {
  debug$2(content`Getting session store...`);
  return localConf.get("sessionStore");
}
function setSession(store, localConf = cliKit) {
  debug$2(content`Setting session store...`);
  localConf.set("sessionStore", store);
}
function removeSession(localConf = cliKit) {
  debug$2(content`Removing session store...`);
  localConf.set("sessionStore", "");
}

var store$2 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  createConf: createConf,
  remove: remove$2,
  getAppInfo: getAppInfo,
  setAppInfo: setAppInfo,
  clearAppInfo: clearAppInfo,
  getTheme: getTheme,
  setTheme: setTheme,
  getSession: getSession,
  setSession: setSession,
  removeSession: removeSession
});

async function latestNpmPackageVersion(name) {
  debug$2(content`Getting the latest version of NPM package: ${token.raw(name)}`);
  return latestVersion(name);
}
function cliVersion() {
  return version$2;
}

var version = /*#__PURE__*/Object.freeze({
  __proto__: null,
  latestNpmPackageVersion: latestNpmPackageVersion,
  cliVersion: cliVersion
});

const genericConfigurationFileNames = {
  yarn: {
    lockfile: "yarn.lock"
  },
  pnpm: {
    lockfile: "pnpm-lock.yaml"
  }
};
const dependencyManager = ["yarn", "npm", "pnpm"];
const PackageJsonNotFoundError = (directory) => {
  return new Abort(`The directory ${directory} doesn't have a package.json.`);
};
function dependencyManagerUsedForCreating(env = process.env) {
  if (env.npm_config_user_agent?.includes("yarn")) {
    return "yarn";
  } else if (env.npm_config_user_agent?.includes("pnpm")) {
    return "pnpm";
  } else {
    return "npm";
  }
}
async function getDependencyManager(directory) {
  debug$2(content`Obtaining the dependency manager in directory ${token.path(directory)}...`);
  const yarnLockPath = join(directory, genericConfigurationFileNames.yarn.lockfile);
  const pnpmLockPath = join(directory, genericConfigurationFileNames.pnpm.lockfile);
  if (await exists(yarnLockPath)) {
    return "yarn";
  } else if (await exists(pnpmLockPath)) {
    return "pnpm";
  } else {
    return "npm";
  }
}
async function installNPMDependenciesRecursively(options) {
  const packageJsons = await glob(join(options.directory, "**/package.json"), {
    ignore: [join(options.directory, "node_modules/**/package.json")],
    cwd: options.directory,
    onlyFiles: true,
    deep: options.deep
  });
  const abortController = new AbortController();
  try {
    await Promise.all(packageJsons.map(async (packageJsonPath) => {
      const directory = dirname(packageJsonPath);
      await install(directory, options.dependencyManager, void 0, void 0, abortController.signal);
    }));
  } catch (error) {
    abortController.abort();
    throw error;
  }
}
async function install(directory, dependencyManager2, stdout, stderr, signal) {
  const options = { cwd: directory, stdout, stderr, signal };
  await exec(dependencyManager2, ["install"], options);
}
async function getPackageName(packageJsonPath) {
  const packageJsonContent = await packageJSONContents(packageJsonPath);
  return packageJsonContent.name;
}
async function getDependencies(packageJsonPath) {
  const packageJsonContent = await packageJSONContents(packageJsonPath);
  const dependencies = packageJsonContent.dependencies ?? {};
  const devDependencies = packageJsonContent.devDependencies ?? {};
  return { ...dependencies, ...devDependencies };
}
async function checkForNewVersion(dependency, currentVersion) {
  debug$2(content`Checking if there's a version of ${dependency} newer than ${currentVersion}`);
  try {
    const lastVersion = await latestNpmPackageVersion(dependency);
    if (lastVersion && new semver$1(currentVersion).compare(lastVersion) < 0) {
      return lastVersion;
    } else {
      return void 0;
    }
  } catch (error) {
    return void 0;
  }
}
function getOutputUpdateCLIReminder(dependencyManager2, version) {
  const updateCommand = token.packagejsonScript(dependencyManager2, "shopify", "upgrade");
  return content`ðŸ’¡ Version ${version} available! Run ${updateCommand}`.value;
}
async function packageJSONContents(packageJsonPath) {
  if (!await exists(packageJsonPath)) {
    throw PackageJsonNotFoundError(dirname(packageJsonPath));
  }
  return JSON.parse(await read$1(packageJsonPath));
}
async function addNPMDependenciesIfNeeded(dependencies, options, force = false) {
  debug$2(content`Adding the following dependencies if needed:
${token.json(dependencies)}
With options:
${token.json(options)}
  `);
  const packageJsonPath = join(options.directory, "package.json");
  if (!await exists(packageJsonPath)) {
    throw PackageJsonNotFoundError(options.directory);
  }
  const existingDependencies = Object.keys(await getDependencies(packageJsonPath));
  let dependenciesToAdd = dependencies;
  if (!force) {
    dependenciesToAdd = dependencies.filter((dep) => {
      return !existingDependencies.includes(dep.name);
    });
  }
  if (dependenciesToAdd.length === 0) {
    return;
  }
  let args;
  const depedenciesWithVersion = dependenciesToAdd.map((dep) => {
    return dep.version ? `${dep.name}@${dep.version}` : dep.name;
  });
  switch (options.dependencyManager) {
    case "npm":
      args = argumentsToAddDependenciesWithNPM(depedenciesWithVersion, options.type);
      break;
    case "yarn":
      args = argumentsToAddDependenciesWithYarn(depedenciesWithVersion, options.type);
      break;
    case "pnpm":
      args = argumentsToAddDependenciesWithPNPM(depedenciesWithVersion, options.type);
      break;
  }
  options.stdout?.write(`Executing...${args.join(" ")}`);
  await exec(options.dependencyManager, args, {
    cwd: options.directory,
    stdout: options.stdout,
    stderr: options.stderr,
    signal: options.signal
  });
}
async function addNPMDependenciesWithoutVersionIfNeeded(dependencies, options) {
  await addNPMDependenciesIfNeeded(dependencies.map((dependency) => {
    return { name: dependency, version: void 0 };
  }), options);
}
async function addLatestNPMDependencies(dependencies, options) {
  await addNPMDependenciesIfNeeded(dependencies.map((dependency) => {
    return { name: dependency, version: "latest" };
  }), options, true);
}
function argumentsToAddDependenciesWithNPM(dependencies, type) {
  let command = ["install"];
  command = command.concat(dependencies);
  switch (type) {
    case "dev":
      command.push("--save-dev");
      break;
    case "peer":
      command.push("--save-peer");
      break;
    case "prod":
      command.push("--save-prod");
      break;
  }
  return command;
}
function argumentsToAddDependenciesWithYarn(dependencies, type) {
  let command = ["add"];
  command = command.concat(dependencies);
  switch (type) {
    case "dev":
      command.push("--dev");
      break;
    case "peer":
      command.push("--peer");
      break;
    case "prod":
      command.push("--prod");
      break;
  }
  return command;
}
function argumentsToAddDependenciesWithPNPM(dependencies, type) {
  let command = ["add"];
  command = command.concat(dependencies);
  switch (type) {
    case "dev":
      command.push("--save-dev");
      break;
    case "peer":
      command.push("--save-peer");
      break;
    case "prod":
      command.push("--save-prod");
      break;
  }
  return command;
}
async function getProjectType(directory) {
  const nodeConfigFile = join(directory, "package.json");
  const rubyConfigFile = join(directory, "Gemfile");
  const phpConfigFile = join(directory, "composer.json");
  if (await exists(nodeConfigFile)) {
    return "node";
  } else if (await exists(rubyConfigFile)) {
    return "ruby";
  } else if (await exists(phpConfigFile)) {
    return "php";
  }
  return void 0;
}

var dependency = /*#__PURE__*/Object.freeze({
  __proto__: null,
  genericConfigurationFileNames: genericConfigurationFileNames,
  dependencyManager: dependencyManager,
  PackageJsonNotFoundError: PackageJsonNotFoundError,
  dependencyManagerUsedForCreating: dependencyManagerUsedForCreating,
  getDependencyManager: getDependencyManager,
  installNPMDependenciesRecursively: installNPMDependenciesRecursively,
  install: install,
  getPackageName: getPackageName,
  getDependencies: getDependencies,
  checkForNewVersion: checkForNewVersion,
  getOutputUpdateCLIReminder: getOutputUpdateCLIReminder,
  packageJSONContents: packageJSONContents,
  addNPMDependenciesIfNeeded: addNPMDependenciesIfNeeded,
  addNPMDependenciesWithoutVersionIfNeeded: addNPMDependenciesWithoutVersionIfNeeded,
  addLatestNPMDependencies: addLatestNPMDependencies,
  getProjectType: getProjectType
});

const url = "https://monorail-edge.shopifysvc.com/v1/produce";
const reportEvent = async (command, args) => {
  if (isDebug() || analyticsDisabled()) {
    return;
  }
  try {
    const currentTime = new Date().getTime();
    const payload = await buildPayload(command, args, currentTime);
    const body = JSON.stringify(payload);
    const headers = buildHeaders$1(currentTime);
    const response = await fetch$2(url, { method: "POST", body, headers });
    if (response.status === 200) {
      debug$2(content`Analytics event sent: ${token.json(payload)}`);
    } else {
      debug$2(`Failed to report usage analytics: ${response.statusText}`);
    }
  } catch (error) {
    let message = "Failed to report usage analytics";
    if (error instanceof Error) {
      message = message.concat(`: ${error.message}`);
    }
    debug$2(message);
  }
};
const buildHeaders$1 = (currentTime) => {
  return {
    "Content-Type": "application/json; charset=utf-8",
    "X-Monorail-Edge-Event-Created-At-Ms": currentTime.toString(),
    "X-Monorail-Edge-Event-Sent-At-Ms": currentTime.toString()
  };
};
const buildPayload = async (command, args = [], currentTime) => {
  let directory = process.cwd();
  const pathFlagIndex = args.indexOf("--path");
  if (pathFlagIndex >= 0) {
    directory = resolve(args[pathFlagIndex + 1]);
  }
  const appInfo = getAppInfo(directory);
  const { platform, arch } = platformAndArch();
  const rawPartnerId = appInfo?.orgId;
  let partnerIdAsInt;
  if (rawPartnerId !== void 0) {
    partnerIdAsInt = parseInt(rawPartnerId, 10);
    if (isNaN(partnerIdAsInt)) {
      partnerIdAsInt = void 0;
    }
  }
  return {
    schema_id: "app_cli3_command/1.0",
    payload: {
      project_type: await getProjectType(join(directory, "web")),
      command,
      args: args.join(" "),
      time_start: currentTime,
      time_end: currentTime,
      total_time: 0,
      success: true,
      uname: `${platform} ${arch}`,
      cli_version: cliVersion(),
      ruby_version: await version$1() || "",
      node_version: process.version.replace("v", ""),
      is_employee: await isShopify(),
      api_key: appInfo?.appId,
      partner_id: partnerIdAsInt
    }
  };
};

var analytics = /*#__PURE__*/Object.freeze({
  __proto__: null,
  url: url,
  reportEvent: reportEvent
});

async function buildHeaders(token) {
  const userAgent = `Shopify CLI; v=${constants$1.versions.cliKit}`;
  await isShopify();
  const headers = {
    "User-Agent": userAgent,
    "Sec-CH-UA-PLATFORM": process.platform,
    "X-Request-Id": randomUUID(),
    authorization: `Bearer ${token}`,
    "X-Shopify-Access-Token": `Bearer ${token}`,
    "Content-Type": "application/json"
  };
  return headers;
}
function sanitizedHeadersOutput(headers) {
  const sanitized = {};
  const keywords = ["token", "authorization"];
  Object.keys(headers).forEach((header) => {
    if (keywords.find((keyword) => header.toLocaleLowerCase().includes(keyword)) === void 0) {
      sanitized[header] = headers[header];
    }
  });
  return Object.keys(sanitized).map((header) => {
    return ` - ${header}: ${sanitized[header]}`;
  }).join("\n");
}

const UnauthorizedAccessError = (store) => {
  const adminLink = token.link(`URL`, `https://${store}/admin`);
  const storeName = store.replace(".myshopify.com", "");
  return new Abort(content`Looks like you need access to this dev store (${token.link(storeName, `https://${store}`)})`, content`â€¢ Log in to the store directly from this ${adminLink}. If you're the store owner, then that direct log in should solve your access issue.
â€¢ If you're not the owner, create a dev store staff account for yourself. Then log in directly from the link above.
    `);
};
const UnknownError = () => {
  return new Bug(`Unknown error connecting to your store`);
};
async function request$1(query, session, variables) {
  const version = await fetchApiVersion(session);
  const url = adminUrl(session.storeFqdn, version);
  const headers = await buildHeaders(session.token);
  debug$2(`
Sending Admin GraphQL request:
${query}

With variables:
${variables ? JSON.stringify(variables, null, 2) : ""}

And headers:
${sanitizedHeadersOutput(headers)}
`);
  try {
    const response = await request$2(url, query, variables, headers);
    return response;
  } catch (error) {
    if (error instanceof ClientError) {
      const errorMessage = content`
The Admin GraphQL API responded unsuccessfully with the HTTP status ${`${error.response.status}`} and errors:

${token.json(error.response.errors)}
      `;
      const abortError = new Abort(errorMessage.value);
      abortError.stack = error.stack;
      throw abortError;
    } else {
      throw error;
    }
  }
}
async function fetchApiVersion(session) {
  const url = adminUrl(session.storeFqdn, "unstable");
  const query = apiVersionQuery();
  const headers = await buildHeaders(session.token);
  debug$2(`
Sending Admin GraphQL request to URL ${url} with query:
${query}
  `);
  const data = await request$2(url, query, {}, headers).catch((err) => {
    throw err.response.status === 403 ? UnauthorizedAccessError(session.storeFqdn) : UnknownError();
  });
  return data.publicApiVersions.filter((item) => item.supported).map((item) => item.handle).sort().reverse()[0];
}
function adminUrl(store, version) {
  const realVersion = version || "unstable";
  return `https://${store}/admin/api/${realVersion}/graphql.json`;
}
function apiVersionQuery() {
  return gql`
    query {
      publicApiVersions {
        handle
        supported
      }
    }
  `;
}

var admin = /*#__PURE__*/Object.freeze({
  __proto__: null,
  request: request$1
});

const FindOrganizationQuery = gql`
  query FindOrganization($id: ID!) {
    organizations(id: $id, first: 1) {
      nodes {
        id
        businessName
        website
        appsNext
        apps(first: 100) {
          nodes {
            id
            title
            apiKey
            organizationId
            apiSecretKeys {
              secret
            }
            appType
          }
        }
      }
    }
  }
`;

const AllOrganizationsQuery = gql`
  {
    organizations(first: 200) {
      nodes {
        id
        businessName
        website
        appsNext
      }
    }
  }
`;

const CreateAppQuery = gql`
  mutation AppCreate($org: Int!, $title: String!, $appUrl: Url!, $redir: [Url]!, $type: AppType) {
    appCreate(
      input: {
        organizationID: $org
        title: $title
        applicationUrl: $appUrl
        redirectUrlWhitelist: $redir
        appType: $type
      }
    ) {
      app {
        id
        apiKey
        title
        appType
        applicationUrl
        redirectUrlWhitelist
        apiSecretKeys {
          secret
        }
        appType
      }
      userErrors {
        field
        message
      }
    }
  }
`;

const UpdateURLsQuery = gql`
  mutation appUpdate($apiKey: String!, $appUrl: Url!, $redir: [Url]!) {
    appUpdate(input: {apiKey: $apiKey, applicationUrl: $appUrl, redirectUrlWhitelist: $redir}) {
      userErrors {
        message
        field
      }
    }
  }
`;

const FindAppQuery = gql`
  query FindApp($apiKey: String!) {
    app(apiKey: $apiKey) {
      id
      title
      apiKey
      organizationId
      apiSecretKeys {
        secret
      }
      appType
    }
  }
`;

const ExtensionUpdateDraftMutation = gql`
  mutation ExtensionUpdateDraft($apiKey: String!, $registrationId: ID!, $config: JSON!, $context: String) {
    extensionUpdateDraft(
      input: {apiKey: $apiKey, registrationId: $registrationId, config: $config, context: $context}
    ) {
      extensionVersion {
        registrationId
        context
        lastUserInteractionAt
        location
        validationErrors {
          field
          message
        }
      }
      userErrors {
        field
        message
      }
    }
  }
`;

const GenerateSignedUploadUrl = gql`
  mutation GenerateSignedUploadUrl($apiKey: String!, $deploymentUuid: String!, $bundleFormat: Int!) {
    deploymentGenerateSignedUploadUrl(
      input: {apiKey: $apiKey, deploymentUuid: $deploymentUuid, bundleFormat: $bundleFormat}
    ) {
      signedUploadUrl
      userErrors {
        field
        message
      }
    }
  }
`;

const CreateDeployment = gql`
  mutation CreateDeployment($apiKey: String!, $uuid: String!, $bundleUrl: String!, $extensions: [ExtensionSettings!]!) {
    deploymentCreate(input: {apiKey: $apiKey, uuid: $uuid, bundleUrl: $bundleUrl, extensions: $extensions}) {
      deployment {
        uuid
      }
      userErrors {
        message
        field
      }
    }
  }
`;

const AllStoresByOrganizationQuery = gql`
  query FindOrganization($id: ID!) {
    organizations(id: $id, first: 1) {
      nodes {
        id
        stores(first: 500, archived: false) {
          nodes {
            shopId
            link
            shopDomain
            shopName
            transferDisabled
            convertableToPartnerTest
          }
        }
      }
    }
  }
`;

const ConvertDevToTestStoreQuery = gql`
  mutation convertDevToTestStore($input: ConvertDevToTestStoreInput!) {
    convertDevToTestStore(input: $input) {
      convertedToTestStore
      userErrors {
        message
        field
      }
    }
  }
`;

const ExtensionCreateQuery = gql`
  mutation ExtensionCreate($apiKey: String!, $type: ExtensionType!, $title: String!, $config: JSON!, $context: String) {
    extensionCreate(input: {apiKey: $apiKey, type: $type, title: $title, config: $config, context: $context}) {
      extensionRegistration {
        id
        uuid
        type
        title
        draftVersion {
          registrationId
          lastUserInteractionAt
          validationErrors {
            field
            message
          }
        }
      }
      userErrors {
        field
        message
      }
    }
  }
`;

const ExtensionSpecificationsQuery = gql`
  query fetchSpecifications($api_key: String!) {
    extensionSpecifications(apiKey: $api_key) {
      name
      identifier
      options {
        managementExperience
      }
      features {
        argo {
          surface
        }
      }
    }
  }
`;

const AllAppExtensionRegistrationsQuery = gql`
  query allAppExtensionRegistrations($apiKey: String!) {
    app(apiKey: $apiKey) {
      extensionRegistrations {
        id
        uuid
        title
        type
      }
    }
  }
`;

const FindProductVariantQuery = gql`
  query {
    products(first: 1) {
      edges {
        node {
          id
          variants(first: 1) {
            edges {
              node {
                id
              }
            }
          }
        }
      }
    }
  }
`;

const ScriptServiceProxyQuery = gql`
  query ProxyRequest($api_key: String, $query: String!, $variables: String) {
    scriptServiceProxy(apiKey: $api_key, query: $query, variables: $variables)
  }
`;

const GetAppFunctionsQuery = gql`
  query GetAppScripts($appKey: String!, $extensionPointName: ExtensionPointName!) {
    appScripts(appKeys: [$appKey], extensionPointName: $extensionPointName) {
      uuid
      title
    }
  }
`;

const ModuleUploadUrlGenerateMutation = gql`
  mutation moduleUploadUrlGenerate {
    moduleUploadUrlGenerate {
      details {
        url
        headers
        humanizedMaxSize
      }
      userErrors {
        field
        message
      }
    }
  }
`;

const AppFunctionSetMutation = gql`
  mutation AppScriptSet(
    $uuid: String
    $extensionPointName: ExtensionPointName!
    $title: String!
    $description: String
    $force: Boolean
    $schemaMajorVersion: String
    $schemaMinorVersion: String
    $scriptConfigVersion: String
    $configurationUi: Boolean!
    $configurationDefinition: String
    $moduleUploadUrl: String!
    $library: LibraryInput
    $inputQuery: String
    $appBridge: AppBridgeInput
    $apiVersion: String
  ) {
    appScriptSet(
      uuid: $uuid
      extensionPointName: $extensionPointName
      title: $title
      description: $description
      force: $force
      schemaMajorVersion: $schemaMajorVersion
      schemaMinorVersion: $schemaMinorVersion
      scriptConfigVersion: $scriptConfigVersion
      configurationUi: $configurationUi
      configurationDefinition: $configurationDefinition
      moduleUploadUrl: $moduleUploadUrl
      library: $library
      inputQuery: $inputQuery
      appBridge: $appBridge
      apiVersion: $apiVersion
    ) {
      userErrors {
        field
        message
        tag
      }
      appScript {
        uuid
        appKey
        configSchema
        extensionPointName
        title
      }
    }
  }
`;

const CompileModuleMutation = gql`
  mutation compileModule($moduleUploadUrl: String!) {
    compileModule(moduleUploadUrl: $moduleUploadUrl) {
      jobId
      userErrors {
        field
        message
      }
    }
  }
`;

const ModuleCompilationStatusQuery = gql`
  query moduleCompilationStatus($jobId: String!) {
    moduleCompilationStatus(jobId: $jobId) {
      status
      userErrors {
        field
        message
      }
    }
  }
`;

const FindOrganizationBasicQuery = gql`
  query FindOrganization($id: ID!) {
    organizations(id: $id, first: 1) {
      nodes {
        id
        businessName
        website
        appsNext
      }
    }
  }
`;

var index = /*#__PURE__*/Object.freeze({
  __proto__: null,
  FindOrganizationQuery: FindOrganizationQuery,
  AllOrganizationsQuery: AllOrganizationsQuery,
  CreateAppQuery: CreateAppQuery,
  UpdateURLsQuery: UpdateURLsQuery,
  FindAppQuery: FindAppQuery,
  ExtensionUpdateDraftMutation: ExtensionUpdateDraftMutation,
  GenerateSignedUploadUrl: GenerateSignedUploadUrl,
  CreateDeployment: CreateDeployment,
  AllStoresByOrganizationQuery: AllStoresByOrganizationQuery,
  ConvertDevToTestStoreQuery: ConvertDevToTestStoreQuery,
  ExtensionCreateQuery: ExtensionCreateQuery,
  ExtensionSpecificationsQuery: ExtensionSpecificationsQuery,
  AllAppExtensionRegistrationsQuery: AllAppExtensionRegistrationsQuery,
  FindProductVariantQuery: FindProductVariantQuery,
  ScriptServiceProxyQuery: ScriptServiceProxyQuery,
  GetAppFunctionsQuery: GetAppFunctionsQuery,
  ModuleUploadUrlGenerateMutation: ModuleUploadUrlGenerateMutation,
  AppFunctionSetMutation: AppFunctionSetMutation,
  CompileModuleMutation: CompileModuleMutation,
  ModuleCompilationStatusQuery: ModuleCompilationStatusQuery,
  FindOrganizationBasicQuery: FindOrganizationBasicQuery
});

class RequestClientError extends ExtendableError {
  constructor(message, statusCode) {
    super(message);
    this.statusCode = statusCode;
  }
}
async function request(query, token$1, variables) {
  const fqdn = await partners$1();
  const url = `https://${fqdn}/api/cli/graphql`;
  const headers = await buildHeaders(token$1);
  debug$2(`
Sending Partners GraphQL request:
${query}

With variables:
${variables ? JSON.stringify(variables, null, 2) : ""}

And headers:
${sanitizedHeadersOutput(headers)}
  `);
  try {
    const response = await request$2(url, query, variables, headers);
    return response;
  } catch (error) {
    if (error instanceof ClientError) {
      const errorMessage = stringifyMessage(content`
The Partners GraphQL API responded unsuccessfully with the HTTP status ${`${error.response.status}`} and errors:

${token.json(error.response.errors)}
      `);
      const mappedError = new RequestClientError(errorMessage, error.response.status);
      mappedError.stack = error.stack;
      throw mappedError;
    } else {
      throw error;
    }
  }
}
async function checkIfTokenIsRevoked(token) {
  const query = gql`
    {
      organizations(first: 1) {
        nodes {
          id
        }
      }
    }
  `;
  const fqdn = await partners$1();
  const url = `https://${fqdn}/api/cli/graphql`;
  const headers = await buildHeaders(token);
  try {
    await request$2(url, query, {}, headers);
    return false;
  } catch (error) {
    if (error instanceof ClientError) {
      return error.response.status === 401;
    }
    return false;
  }
}
async function functionProxyRequest(apiKey, query, token, variables) {
  const proxyVariables = {
    api_key: apiKey,
    query,
    variables: JSON.stringify(variables) || "{}"
  };
  const proxyQuery = ScriptServiceProxyQuery;
  const res = await request(proxyQuery, token, proxyVariables);
  const json = JSON.parse(res.scriptServiceProxy);
  return json;
}

var partners = /*#__PURE__*/Object.freeze({
  __proto__: null,
  RequestClientError: RequestClientError,
  request: request,
  checkIfTokenIsRevoked: checkIfTokenIsRevoked,
  functionProxyRequest: functionProxyRequest
});

var api = /*#__PURE__*/Object.freeze({
  __proto__: null,
  admin: admin,
  partners: partners,
  graphql: index
});

const InvalidChecksumError = ({ file, expected, got }) => {
  return new Abort(`The validation of ${file} failed. We expected the checksum ${expected}, but got ${got})`);
};
async function validateMD5({ file, md5FileURL }) {
  debug$2(`Checking MD5 of file ${token.path(file)} against the MD5 in ${token.link("URL", md5FileURL)}`);
  const md5Digest = await md5File(file);
  const md5Response = await fetch$2(md5FileURL);
  const md5Contents = await md5Response.text();
  const canonicalMD5 = md5Contents.split(" ")[0];
  if (!(canonicalMD5 === md5Digest)) {
    throw InvalidChecksumError({
      file,
      got: md5Digest,
      expected: canonicalMD5
    });
  }
}

var checksum = /*#__PURE__*/Object.freeze({
  __proto__: null,
  InvalidChecksumError: InvalidChecksumError,
  validateMD5: validateMD5
});

const globalFlags = {
  verbose: Flags.boolean({
    hidden: false,
    description: "Increase the verbosity of the logs.",
    env: "SHOPIFY_FLAG_VERBOSE"
  })
};

var cli = /*#__PURE__*/Object.freeze({
  __proto__: null,
  globalFlags: globalFlags
});

const DotEnvNotFoundError = (path) => {
  return new Abort(`The environment file at ${path} does not exist.`);
};
async function read(path) {
  debug$2(content`Reading the .env file at ${token.path(path)}`);
  if (!await exists(path)) {
    throw DotEnvNotFoundError(path);
  }
  const content$1 = await read$1(path);
  return {
    path,
    variables: parse$2(content$1)
  };
}
async function write(file) {
  await write$1(file.path, stringify(file.variables));
}

var dotEnv = /*#__PURE__*/Object.freeze({
  __proto__: null,
  DotEnvNotFoundError: DotEnvNotFoundError,
  read: read,
  write: write
});

const factory = git$1;
const GitNotPresentError = () => {
  return new Abort(`Git is necessary in the environment to continue`, content`Install ${token.link("git", "https://git-scm.com/book/en/v2/Getting-Started-Installing-Git")}`);
};
async function initializeRepository(directory) {
  debug$2(content`Initializing git repository at ${token.path(directory)}...`);
  await ensurePresentOrAbort();
  await git$1(directory).init();
}
async function downloadRepository({
  repoUrl,
  destination,
  progressUpdater,
  shallow
}) {
  debug$2(content`Git-cloning repository ${repoUrl} into ${token.path(destination)}...`);
  await ensurePresentOrAbort();
  const [repository, branch] = repoUrl.split("#");
  const options = { "--recurse-submodules": null };
  if (branch) {
    options["--branch"] = branch;
  }
  if (shallow) {
    options["--depth"] = 1;
  }
  const progress = ({ stage, progress: progress2, processed, total }) => {
    const updateString = `${stage}, ${processed}/${total} objects (${progress2}% complete)`;
    if (progressUpdater)
      progressUpdater(updateString);
  };
  await git$1({ progress }).clone(repository, destination, options, (err) => {
    if (err) {
      const abortError = new Abort(err.message);
      abortError.stack = err.stack;
      throw abortError;
    }
  });
}
async function ensurePresentOrAbort() {
  if (!await hasGit()) {
    throw GitNotPresentError();
  }
}

var git = /*#__PURE__*/Object.freeze({
  __proto__: null,
  factory: factory,
  GitNotPresentError: GitNotPresentError,
  initializeRepository: initializeRepository,
  downloadRepository: downloadRepository,
  ensurePresentOrAbort: ensurePresentOrAbort
});

class GitHubClientError extends Error {
  constructor(url, statusCode, bodyJson) {
    super(`The request to GitHub API URL ${url} failed with status code ${statusCode} and the following error message: ${bodyJson.message}`);
  }
}
async function getLatestRelease(user, repo, { filter } = { filter: () => true }) {
  debug$2(content`Getting the latest release of GitHub repository ${user}/${repo}...`);
  const url = `https://api.github.com/repos/${user}/${repo}/releases`;
  const fetchResult = await fetch$2(url);
  const jsonBody = await fetchResult.json();
  if (fetchResult.status !== 200) {
    throw new GitHubClientError(url, fetchResult.status, jsonBody);
  }
  return jsonBody.find(filter);
}
function parseRepoUrl(src) {
  const match = /^(?:(?:https:\/\/)?([^:/]+\.[^:/]+)\/|git@([^:/]+)[:/]|([^/]+):)?([^/\s]+)\/([^/\s#]+)(?:((?:\/[^/\s#]+)+))?(?:\/)?(?:#(.+))?/.exec(src);
  if (!match) {
    const exampleFormats = [
      "github:user/repo",
      "user/repo/subdirectory",
      "git@github.com:user/repo",
      "user/repo#dev",
      "https://github.com/user/repo"
    ];
    throw new Abort(`Parsing the url ${src} failed. Supported formats are ${exampleFormats.join(", ")}.`);
  }
  const site = match[1] || match[2] || match[3] || "github.com";
  const normalizedSite = site === "github" ? "github.com" : site;
  const user = match[4];
  const name = match[5].replace(/\.git$/, "");
  const subDirectory = match[6]?.slice(1);
  const ref = match[7];
  const branch = ref ? `#${ref}` : "";
  const ssh = `git@${normalizedSite}:${user}/${name}`;
  const http = `https://${normalizedSite}/${user}/${name}`;
  const full = ["https:/", normalizedSite, user, name, subDirectory].join("/").concat(branch);
  return { full, site: normalizedSite, user, name, ref, subDirectory, ssh, http };
}
function parseGithubRepoReference(src) {
  const url = new URL(src);
  const branch = url.hash ? url.hash.slice(1) : void 0;
  const [_, user, repo, ...repoPath] = url.pathname.split("/");
  const filePath = repoPath.length > 0 ? repoPath.join("/") : void 0;
  return {
    repoBaseUrl: `${url.origin}/${user}/${repo}`,
    branch,
    filePath
  };
}

var github = /*#__PURE__*/Object.freeze({
  __proto__: null,
  getLatestRelease: getLatestRelease,
  parseRepoUrl: parseRepoUrl,
  parseGithubRepoReference: parseGithubRepoReference
});

const haikunator = new Haikunator();
function generate(suffix) {
  const generated = haikunator.haikunate();
  const [adjective, noun, token] = generated.split("-");
  return [adjective, noun, suffix, token].join("-");
}

var haiku = /*#__PURE__*/Object.freeze({
  __proto__: null,
  generate: generate
});

const generateRandomUUID = () => {
  return randomUUID();
};
const generateShortId = () => {
  let result = "";
  const characters = "abcdefghijklmnopqrstuvwxyz0123456789";
  const charactersLength = characters.length;
  for (let i = 0; i < 7; i++) {
    result += characters.charAt(Math.floor(Math.random() * charactersLength));
  }
  return result;
};

var id = /*#__PURE__*/Object.freeze({
  __proto__: null,
  generateRandomUUID: generateRandomUUID,
  generateShortId: generateShortId
});

async function readPackageJSON(directory) {
  debug$2(content`Reading and decoding the content from package.json at ${token.path(directory)}...`);
  const packagePath = join(directory, "package.json");
  const packageJSON = JSON.parse(await read$1(packagePath));
  return packageJSON;
}
async function writePackageJSON(directory, packageJSON) {
  debug$2(content`JSON-encoding and writing content to package.json at ${token.path(directory)}...`);
  const packagePath = join(directory, "package.json");
  await write$1(packagePath, JSON.stringify(packageJSON, null, 2));
}
async function updateAppData(packageJSON, name) {
  packageJSON.name = name;
  packageJSON.author = await username() ?? "";
}

var npm = /*#__PURE__*/Object.freeze({
  __proto__: null,
  readPackageJSON: readPackageJSON,
  writePackageJSON: writePackageJSON,
  updateAppData: updateAppData
});

const TUNNEL_PLUGINS = ["@shopify/plugin-ngrok"];
async function lookupTunnelPlugin(plugins) {
  debug$2(content`Looking up the Ngrok tunnel plugin...`);
  const tunnelPlugin = plugins.find((plugin) => TUNNEL_PLUGINS.includes(plugin.name));
  if (!tunnelPlugin)
    return void 0;
  const tunnelPath = pathToFileURL(join(tunnelPlugin.root, "dist/tunnel.js")).toString();
  return import(tunnelPath).catch(() => void 0);
}

var plugins = /*#__PURE__*/Object.freeze({
  __proto__: null,
  lookupTunnelPlugin: lookupTunnelPlugin
});

async function getRandomPort() {
  debug$2(content`Getting a random port...`);
  const randomPort = await port$1.getRandomPort();
  debug$2(content`Random port obtained: ${token.raw(`${randomPort}`)}`);
  return randomPort;
}

var port = /*#__PURE__*/Object.freeze({
  __proto__: null,
  getRandomPort: getRandomPort
});

var schema = /*#__PURE__*/Object.freeze({
  __proto__: null,
  define: z
});

function clientId() {
  const environment = identity$1();
  if (environment === Environment.Local) {
    return "e5380e02-312a-7408-5718-e07017e9cf52";
  } else if (environment === Environment.Production) {
    return "fbdb2649-e327-4907-8f67-908d24cfd7e3";
  } else {
    return "e5380e02-312a-7408-5718-e07017e9cf52";
  }
}
function applicationId(api) {
  switch (api) {
    case "admin": {
      const environment = shopify$1();
      if (environment === Environment.Local) {
        return "e92482cebb9bfb9fb5a0199cc770fde3de6c8d16b798ee73e36c9d815e070e52";
      } else if (environment === Environment.Production) {
        return "7ee65a63608843c577db8b23c4d7316ea0a01bd2f7594f8a9c06ea668c1b775c";
      } else {
        return "e92482cebb9bfb9fb5a0199cc770fde3de6c8d16b798ee73e36c9d815e070e52";
      }
    }
    case "partners": {
      const environment = partners$2();
      if (environment === Environment.Local) {
        return "df89d73339ac3c6c5f0a98d9ca93260763e384d51d6038da129889c308973978";
      } else if (environment === Environment.Production) {
        return "271e16d403dfa18082ffb3d197bd2b5f4479c3fc32736d69296829cbb28d41a6";
      } else {
        return "df89d73339ac3c6c5f0a98d9ca93260763e384d51d6038da129889c308973978";
      }
    }
    case "storefront-renderer": {
      const environment = shopify$1();
      if (environment === Environment.Local) {
        return "46f603de-894f-488d-9471-5b721280ff49";
      } else if (environment === Environment.Production) {
        return "ee139b3d-5861-4d45-b387-1bc3ada7811c";
      } else {
        return "46f603de-894f-488d-9471-5b721280ff49";
      }
    }
    default:
      throw new Bug(`Application id for API of type: ${api}`);
  }
}

function validateScopes(requestedScopes, identity) {
  const currentScopes = identity.scopes;
  return requestedScopes.every((scope) => currentScopes.includes(scope));
}
async function validateSession(scopes, applications, session) {
  if (!session)
    return "needs_full_auth";
  const scopesAreValid = validateScopes(scopes, session.identity);
  if (!scopesAreValid)
    return "needs_full_auth";
  let tokensAreExpired = isTokenExpired(session.identity);
  let tokensAreRevoked = false;
  if (applications.partnersApi) {
    const appId = applicationId("partners");
    const token = session.applications[appId];
    tokensAreRevoked = tokensAreRevoked || await isPartnersTokenRevoked(token);
    tokensAreExpired = tokensAreExpired || isTokenExpired(token);
  }
  if (applications.storefrontRendererApi) {
    const appId = applicationId("storefront-renderer");
    const token = session.applications[appId];
    tokensAreExpired = tokensAreExpired || isTokenExpired(token);
  }
  if (applications.adminApi) {
    const appId = applicationId("admin");
    const realAppId = `${applications.adminApi.storeFqdn}-${appId}`;
    const token = session.applications[realAppId];
    tokensAreExpired = tokensAreExpired || isTokenExpired(token);
  }
  if (tokensAreRevoked)
    return "needs_full_auth";
  if (tokensAreExpired)
    return "needs_refresh";
  return "ok";
}
function isTokenExpired(token) {
  if (!token)
    return true;
  return token.expiresAt < expireThreshold();
}
async function isPartnersTokenRevoked(token) {
  if (!token)
    return false;
  return checkIfTokenIsRevoked(token.accessToken);
}
function expireThreshold() {
  return new Date(Date.now() + constants$1.session.expirationTimeMarginInMinutes * 60 * 1e3);
}

const allAPIs = ["admin", "storefront-renderer", "partners"];

function allDefaultScopes(extraScopes = []) {
  let scopes = allAPIs.map(defaultApiScopes).flat();
  scopes = ["openid", ...scopes, ...extraScopes].map(scopeTransform);
  return Array.from(new Set(scopes));
}
function apiScopes(api, extraScopes = []) {
  const scopes = ["openid", ...defaultApiScopes(api), ...extraScopes.map(scopeTransform)].map(scopeTransform);
  return Array.from(new Set(scopes));
}
function defaultApiScopes(api) {
  switch (api) {
    case "admin":
      return ["graphql", "themes", "collaborator"];
    case "storefront-renderer":
      return ["devtools"];
    case "partners":
      return ["cli"];
    default:
      throw new Bug(`Unknown API: ${api}`);
  }
}
function scopeTransform(scope) {
  switch (scope) {
    case "graphql":
      return "https://api.shopify.com/auth/shop.admin.graphql";
    case "themes":
      return "https://api.shopify.com/auth/shop.admin.themes";
    case "collaborator":
      return "https://api.shopify.com/auth/partners.collaborator-relationships.readonly";
    case "cli":
      return "https://api.shopify.com/auth/partners.app.cli.access";
    case "devtools":
      return "https://api.shopify.com/auth/shop.storefront-renderer.devtools";
    default:
      return scope;
  }
}

class InvalidGrantError extends Error {
}
async function exchangeCodeForAccessToken(codeData) {
  const clientId$1 = await clientId();
  const params = {
    grant_type: "authorization_code",
    code: codeData.code,
    redirect_uri: "http://127.0.0.1:3456",
    client_id: clientId$1,
    code_verifier: codeData.codeVerifier
  };
  return tokenRequest(params).then(buildIdentityToken);
}
async function exchangeAccessForApplicationTokens(identityToken, scopes, store) {
  const token = identityToken.accessToken;
  const partners = await requestAppToken("partners", token, scopes.partners);
  const storefront = await requestAppToken("storefront-renderer", token, scopes.storefront);
  const result = {
    ...partners,
    ...storefront
  };
  if (store) {
    const admin = await requestAppToken("admin", token, scopes.admin, store);
    Object.assign(result, admin);
  }
  return result;
}
async function refreshAccessToken(currentToken) {
  const clientId$1 = await clientId();
  const params = {
    grant_type: "refresh_token",
    access_token: currentToken.accessToken,
    refresh_token: currentToken.refreshToken,
    client_id: clientId$1
  };
  return tokenRequest(params).then(buildIdentityToken);
}
async function exchangeCustomPartnerToken(token) {
  const appId = applicationId("partners");
  const newToken = await requestAppToken("partners", token, ["https://api.shopify.com/auth/partners.app.cli.access"]);
  return newToken[appId];
}
async function requestAppToken(api, token, scopes = [], store) {
  const appId = applicationId(api);
  const clientId$1 = await clientId();
  const params = {
    grant_type: "urn:ietf:params:oauth:grant-type:token-exchange",
    requested_token_type: "urn:ietf:params:oauth:token-type:access_token",
    subject_token_type: "urn:ietf:params:oauth:token-type:access_token",
    client_id: clientId$1,
    audience: appId,
    scope: scopes.join(" "),
    subject_token: token,
    ...api === "admin" && { destination: `https://${store}/admin` }
  };
  let identifier = appId;
  if (api === "admin" && store) {
    identifier = `${store}-${appId}`;
  }
  const appToken = await tokenRequest(params).then(buildApplicationToken);
  return { [identifier]: appToken };
}
async function tokenRequest(params) {
  const fqdn = await identity();
  const url = new URL(`https://${fqdn}/oauth/token`);
  url.search = new URLSearchParams(Object.entries(params)).toString();
  const res = await fetch$2(url.href, { method: "POST" });
  const payload = await res.json();
  if (!res.ok) {
    if (payload.error === "invalid_grant") {
      throw new InvalidGrantError(payload.error_description);
    } else {
      throw new Abort(payload.error_description);
    }
  }
  return payload;
}
function buildIdentityToken(result) {
  return {
    accessToken: result.access_token,
    refreshToken: result.refresh_token,
    expiresAt: new Date(Date.now() + result.expires_in * 1e3),
    scopes: result.scope.split(" ")
  };
}
function buildApplicationToken(result) {
  return {
    accessToken: result.access_token,
    expiresAt: new Date(Date.now() + result.expires_in * 1e3),
    scopes: result.scope.split(" ")
  };
}

const HTMLFileNames = ["empty-url.html", "auth-error.html", "missing-code.html", "missing-state.html", "success.html"];
const StylesheetFilename = "style.css";
const FaviconFileName = "favicon.svg";
const getFilePath = async (fileName) => {
  const filePath = await findUp(`assets/${fileName}`, {
    type: "file",
    cwd: moduleDirectory(import.meta.url)
  });
  if (!filePath) {
    throw RedirectPageAssetNotFoundError();
  }
  return filePath;
};
const getEmptyUrlHTML = async () => {
  const filePath = await getFilePath(HTMLFileNames[0]);
  return read$1(filePath);
};
const getAuthErrorHTML = async () => {
  const filePath = await getFilePath(HTMLFileNames[1]);
  return read$1(filePath);
};
const getMissingCodeHTML = async () => {
  const filePath = await getFilePath(HTMLFileNames[2]);
  return read$1(filePath);
};
const getMissingStateHTML = async () => {
  const filePath = await getFilePath(HTMLFileNames[3]);
  return read$1(filePath);
};
const getSuccessHTML = async () => {
  const filePath = await getFilePath(HTMLFileNames[4]);
  return read$1(filePath);
};
const getStylesheet = async () => {
  const filePath = await getFilePath(StylesheetFilename);
  return read$1(filePath);
};
const getFavicon = async () => {
  const filePath = await getFilePath(FaviconFileName);
  return read$1(filePath);
};
const EmptyUrlString = "We received the authentication redirect but the URL is empty.";
const MissingCodeString = "The authentication can't continue because the redirect doesn't include the code.";
const MissingStateString = "The authentication can't continue because the redirect doesn't include the state.";
const RedirectPageAssetNotFoundError = () => new Bug(`Redirect page asset not found`);

const ResponseTimeoutSeconds = 10;
const ServerStopDelaySeconds = 0.5;
class RedirectListener {
  static createServer(callback) {
    const server = Fastify__default().get("*", async (request, reply) => {
      const requestUrl = request.url;
      if (requestUrl === "/favicon.svg") {
        const faviconFile = await getFavicon();
        reply.header("Content-Type", "image/svg+xml").send(faviconFile);
        return {};
      } else if (requestUrl === "/style.css") {
        const stylesheetFile = await getStylesheet();
        reply.header("Content-Type", "text/css").send(stylesheetFile);
        return {};
      }
      const respond = (contents, error, state, code) => {
        reply.header("Content-Type", "text/html").send(contents);
        callback(error, state, code);
        return {};
      };
      if (!requestUrl) {
        const file2 = await getEmptyUrlHTML();
        const err = new Bug(EmptyUrlString);
        return respond(file2, err, void 0, void 0);
      }
      const queryObject = url$1.parse(requestUrl, true).query;
      if (queryObject.error && queryObject.error_description) {
        const file2 = await getAuthErrorHTML();
        const err = new Abort(`${queryObject.error_description}`);
        return respond(file2, err, void 0, void 0);
      }
      if (!queryObject.code) {
        const file2 = await getMissingCodeHTML();
        const err = new Bug(MissingCodeString);
        return respond(file2, err, void 0, void 0);
      }
      if (!queryObject.state) {
        const file2 = await getMissingStateHTML();
        const err = new Bug(MissingStateString);
        return respond(file2, err, void 0, void 0);
      }
      const file = await getSuccessHTML();
      return respond(file, void 0, `${queryObject.code}`, `${queryObject.state}`);
    });
    return server;
  }
  constructor(options) {
    this.port = options.port;
    this.host = options.host;
    this.server = RedirectListener.createServer(options.callback);
  }
  start() {
    this.server.listen({ port: this.port, host: this.host }, () => {
    });
  }
  async stop() {
    await this.server.close();
  }
}
async function listenRedirect(host, port, url2) {
  const result = await new Promise((resolve, reject) => {
    const timeout = setTimeout(() => {
      const message = "\nAuto-open timed out. Open the login page: ";
      info(content`${message}${token.link("Log in to Shopify Partners", url2)}\n`);
    }, ResponseTimeoutSeconds * 1e3);
    const callback = async (error, code, state) => {
      clearTimeout(timeout);
      setTimeout(() => {
        redirectListener.stop();
        if (error)
          reject(error);
        else
          resolve({ code, state });
      }, ServerStopDelaySeconds * 1e3);
    };
    const redirectListener = new RedirectListener({ host, port, callback });
    redirectListener.start();
  });
  return result;
}

function randomHex(size) {
  return crypto.randomBytes(size).toString("hex");
}
function generateRandomChallengePair() {
  const codeVerifier = base64URLEncode(crypto.randomBytes(32));
  const codeChallenge = base64URLEncode(sha256(codeVerifier));
  return { codeVerifier, codeChallenge };
}
function base64URLEncode(str) {
  return str.toString("base64").replace(/\+/g, "-").replace(/\//g, "_").replace(/[=]/g, "");
}
function sha256(str) {
  return crypto.createHash("sha256").update(str).digest();
}
function capitalize(string) {
  return string.substring(0, 1).toUpperCase() + string.substring(1);
}
function normalizeStoreName(store) {
  const storeFqdn = store.replace(/^https?:\/\//, "").replace(/\/$/, "");
  return storeFqdn.includes(".myshopify.com") ? storeFqdn : `${storeFqdn}.myshopify.com`;
}

var string = /*#__PURE__*/Object.freeze({
  __proto__: null,
  randomHex: randomHex,
  generateRandomChallengePair: generateRandomChallengePair,
  capitalize: capitalize,
  normalizeStoreName: normalizeStoreName,
  camelize: camelCase,
  hyphenize: paramCase,
  underscore: snakeCase,
  constantize: constantCase
});

const MismatchStateError = new Abort("The state received from the authentication doesn't match the one that initiated the authentication process.");
async function authorize(scopes, state = randomHex(30)) {
  const port = 3456;
  const host = "127.0.0.1";
  const redirectUri = `http://${host}:${port}`;
  const fqdn = await identity();
  const identityClientId = await clientId();
  let url = `http://${fqdn}/oauth/authorize`;
  const { codeVerifier, codeChallenge } = generateRandomChallengePair();
  const params = {
    client_id: identityClientId,
    scope: scopes.join(" "),
    redirect_uri: redirectUri,
    state,
    response_type: "code",
    code_challenge_method: "S256",
    code_challenge: codeChallenge
  };
  info("\nTo run this command, log in to Shopify Partners.");
  info("\u{1F449} Press any key to open the login page on your browser");
  await keypress();
  url = `${url}?${new URLSearchParams(params).toString()}`;
  open(url);
  const result = await listenRedirect(host, port, url);
  if (result.state !== state) {
    throw MismatchStateError;
  }
  return { code: result.code, codeVerifier };
}

const DateSchema = z.preprocess((arg) => {
  if (typeof arg === "string" || arg instanceof Date)
    return new Date(arg);
  return null;
}, z.date());
const IdentityTokenSchema = z.object({
  accessToken: z.string(),
  refreshToken: z.string(),
  expiresAt: DateSchema,
  scopes: z.array(z.string())
});
const ApplicationTokenSchema = z.object({
  accessToken: z.string(),
  expiresAt: DateSchema,
  scopes: z.array(z.string())
});
const SessionSchema = z.object({}).catchall(z.object({
  identity: IdentityTokenSchema,
  applications: z.object({}).catchall(ApplicationTokenSchema)
}));

async function fetch$1(identifier) {
  debug$2(content`Reading ${identifier} from the secure store...`);
  try {
    const keytar = await import('keytar');
    const content = await keytar.getPassword(constants$1.keychain.service, identifier);
    return content;
  } catch (error) {
    throw createAbort(error, "Unable to read from the secure store");
  }
}
async function store$1(identifier, content$1) {
  debug$2(content`Updating ${identifier} in the secure store with new content...`);
  try {
    const keytar = await import('keytar');
    await keytar.default.setPassword(constants$1.keychain.service, identifier, content$1);
  } catch (error) {
    throw createAbort(error, "Unable to update the secure store");
  }
}
async function remove$1(identifier) {
  debug$2(content`Removing ${identifier} from the secure store...`);
  try {
    const keytar = await import('keytar');
    const result = await keytar.default.deletePassword(constants$1.keychain.service, identifier);
    return result;
  } catch (error) {
    throw createAbort(error, "Unable to remove from the secure store");
  }
}
function createAbort(error, message) {
  let newMessage = message;
  let stack = "";
  if (error instanceof Error) {
    newMessage = message.concat(`: ${error.message}`);
    stack = error.stack;
  }
  const abort = new Abort(newMessage);
  abort.stack = stack;
  return abort;
}

const identifier = "session";
async function store(session) {
  const jsonSession = JSON.stringify(session);
  if (await secureStoreAvailable()) {
    await store$1(identifier, jsonSession);
  } else {
    setSession(jsonSession);
  }
}
async function fetch() {
  let content2;
  if (await secureStoreAvailable()) {
    content2 = await fetch$1(identifier);
  } else {
    content2 = getSession();
  }
  if (!content2) {
    return void 0;
  }
  const contentJson = JSON.parse(content2);
  const parsedSession = await SessionSchema.safeParseAsync(contentJson);
  if (parsedSession.success) {
    return parsedSession.data;
  } else {
    await remove();
    return void 0;
  }
}
async function remove() {
  if (await secureStoreAvailable()) {
    await remove$1(identifier);
  } else {
    removeSession();
  }
}
async function secureStoreAvailable() {
  try {
    if (platformAndArch().platform === "windows") {
      debug$2(content`Secure store not supported on Windows`);
      return false;
    }
    const keytar = await import('keytar');
    await keytar.default.findCredentials(constants$1.keychain.service);
    debug$2(content`Secure store is available`);
    return true;
  } catch (_error) {
    debug$2(content`Failed to load secure store`);
    return false;
  }
}

const NoSessionError = new Bug("No session found after ensuring authenticated");
const MissingPartnerTokenError = new Bug("No partners token found after ensuring authenticated");
const MissingAdminTokenError = new Bug("No admin token found after ensuring authenticated");
const MissingStorefrontTokenError = new Bug("No storefront token found after ensuring authenticated");
const PartnerOrganizationNotFoundError = () => {
  return new Abort(`Couldn't find your Shopify Partners organization`, `Have you confirmed your accounts from the emails you received?`);
};
async function ensureAuthenticatedPartners(scopes = [], env = process.env) {
  debug$2(content`Ensuring that the user is authenticated with the Partners API with the following scopes:
${token.json(scopes)}
`);
  const envToken = env[constants$1.environmentVariables.partnersToken];
  if (envToken) {
    return (await exchangeCustomPartnerToken(envToken)).accessToken;
  }
  const tokens = await ensureAuthenticated({ partnersApi: { scopes } });
  if (!tokens.partners) {
    throw MissingPartnerTokenError;
  }
  return tokens.partners;
}
async function ensureAuthenticatedStorefront(scopes = []) {
  debug$2(content`Ensuring that the user is authenticated with the Storefront API with the following scopes:
${token.json(scopes)}
`);
  const tokens = await ensureAuthenticated({ storefrontRendererApi: { scopes } });
  if (!tokens.storefront) {
    throw MissingStorefrontTokenError;
  }
  return tokens.storefront;
}
async function ensureAuthenticatedAdmin(store, scopes = []) {
  debug$2(content`Ensuring that the user is authenticated with the Admin API with the following scopes for the store ${token.raw(store)}:
${token.json(scopes)}
`);
  const tokens = await ensureAuthenticated({ adminApi: { scopes, storeFqdn: store } });
  if (!tokens.admin) {
    throw MissingAdminTokenError;
  }
  return tokens.admin;
}
async function ensureAuthenticated(applications, env = process.env) {
  const fqdn = await identity();
  if (applications.adminApi?.storeFqdn) {
    applications.adminApi.storeFqdn = normalizeStoreName(applications.adminApi.storeFqdn);
  }
  const currentSession = await fetch() || {};
  const fqdnSession = currentSession[fqdn];
  const scopes = getFlattenScopes(applications);
  debug$2(content`Validating existing session against the scopes:
${token.json(scopes)}
For applications:
${token.json(applications)}
`);
  const validationResult = await validateSession(scopes, applications, fqdnSession);
  let newSession = {};
  if (validationResult === "needs_full_auth") {
    debug$2(content`Initiating the full authentication flow...`);
    newSession = await executeCompleteFlow(applications, fqdn);
  } else if (validationResult === "needs_refresh") {
    debug$2(content`The current session is valid but needs refresh. Refreshing...`);
    try {
      newSession = await refreshTokens(fqdnSession.identity, applications, fqdn);
    } catch (error) {
      if (error instanceof InvalidGrantError) {
        newSession = await executeCompleteFlow(applications, fqdn);
      } else {
        throw error;
      }
    }
  }
  const completeSession = { ...currentSession, ...newSession };
  await store(completeSession);
  const tokens = await tokensFor(applications, completeSession, fqdn);
  const envToken = env[constants$1.environmentVariables.partnersToken];
  if (envToken && applications.partnersApi) {
    tokens.partners = (await exchangeCustomPartnerToken(envToken)).accessToken;
  }
  if (!envToken && tokens.partners) {
    await ensureUserHasPartnerAccount(tokens.partners);
  }
  return tokens;
}
async function hasPartnerAccount(partnersToken) {
  try {
    await request(gql`
        {
          organizations(first: 1) {
            nodes {
              id
            }
          }
        }
      `, partnersToken);
    return true;
  } catch (error) {
    if (error instanceof RequestClientError && error.statusCode === 404) {
      return false;
    } else {
      return true;
    }
  }
}
async function ensureUserHasPartnerAccount(partnersToken) {
  debug$2(content`Verifying that the user has a Partner organization`);
  if (!await hasPartnerAccount(partnersToken)) {
    info(`
A Shopify Partners organization is needed to proceed.`);
    info(`\u{1F449} Press any key to create one`);
    await keypress();
    open(`https://partners.shopify.com/signup`);
    info(content`ðŸ‘‰ Press any key when you have ${token.cyan("created the organization")}`);
    warn(content`Make sure you've confirmed your Shopify and the Partner organization from the email`);
    await keypress();
    if (!await hasPartnerAccount(partnersToken)) {
      throw PartnerOrganizationNotFoundError();
    }
  }
}
async function executeCompleteFlow(applications, identityFqdn2) {
  const scopes = getFlattenScopes(applications);
  const exchangeScopes = getExchangeScopes(applications);
  const store = applications.adminApi?.storeFqdn;
  debug$2(content`Authorizing through Identity's website...`);
  const code = await authorize(scopes);
  debug$2(content`Authorization code received. Exchanging it for a CLI token...`);
  const identityToken = await exchangeCodeForAccessToken(code);
  debug$2(content`CLI token received. Exchanging it for application tokens...`);
  const result = await exchangeAccessForApplicationTokens(identityToken, exchangeScopes, store);
  const session = {
    [identityFqdn2]: {
      identity: identityToken,
      applications: result
    }
  };
  completed("Logged in.");
  return session;
}
async function refreshTokens(token2, applications, fqdn) {
  const identityToken = await refreshAccessToken(token2);
  const exchangeScopes = getExchangeScopes(applications);
  const applicationTokens = await exchangeAccessForApplicationTokens(identityToken, exchangeScopes, applications.adminApi?.storeFqdn);
  return {
    [fqdn]: {
      identity: identityToken,
      applications: applicationTokens
    }
  };
}
async function tokensFor(applications, session, fqdn) {
  const fqdnSession = session[fqdn];
  if (!fqdnSession) {
    throw NoSessionError;
  }
  const tokens = {};
  if (applications.adminApi) {
    const appId = applicationId("admin");
    const realAppId = `${applications.adminApi.storeFqdn}-${appId}`;
    const token2 = fqdnSession.applications[realAppId]?.accessToken;
    if (token2) {
      tokens.admin = { token: token2, storeFqdn: applications.adminApi.storeFqdn };
    }
  }
  if (applications.partnersApi) {
    const appId = applicationId("partners");
    tokens.partners = fqdnSession.applications[appId]?.accessToken;
  }
  if (applications.storefrontRendererApi) {
    const appId = applicationId("storefront-renderer");
    tokens.storefront = fqdnSession.applications[appId]?.accessToken;
  }
  return tokens;
}
function getFlattenScopes(apps) {
  const admin = apps.adminApi?.scopes || [];
  const partner = apps.partnersApi?.scopes || [];
  const storefront = apps.storefrontRendererApi?.scopes || [];
  const requestedScopes = [...admin, ...partner, ...storefront];
  return allDefaultScopes(requestedScopes);
}
function getExchangeScopes(apps) {
  const adminScope = apps.adminApi?.scopes || [];
  const partnerScope = apps.partnersApi?.scopes || [];
  const storefrontScopes = apps.storefrontRendererApi?.scopes || [];
  return {
    admin: apiScopes("admin", adminScope),
    partners: apiScopes("partners", partnerScope),
    storefront: apiScopes("storefront-renderer", storefrontScopes)
  };
}
function logout() {
  return remove();
}

var session = /*#__PURE__*/Object.freeze({
  __proto__: null,
  PartnerOrganizationNotFoundError: PartnerOrganizationNotFoundError,
  ensureAuthenticatedPartners: ensureAuthenticatedPartners,
  ensureAuthenticatedStorefront: ensureAuthenticatedStorefront,
  ensureAuthenticatedAdmin: ensureAuthenticatedAdmin,
  ensureAuthenticated: ensureAuthenticated,
  hasPartnerAccount: hasPartnerAccount,
  ensureUserHasPartnerAccount: ensureUserHasPartnerAccount,
  logout: logout
});

function create(templateContent) {
  return (data) => {
    const engine = new Liquid();
    return engine.render(engine.parse(templateContent), data);
  };
}
async function recursiveDirectoryCopy(from, to, data) {
  debug$2(content`Copying template from directory ${token.path(from)} to ${token.path(to)}`);
  const templateFiles = await glob(join(from, "**/*"), { dot: true });
  const sortedTemplateFiles = templateFiles.map((path) => path.split("/")).sort((lhs, rhs) => lhs.length < rhs.length ? 1 : -1).map((components) => components.join("/"));
  await Promise.all(sortedTemplateFiles.map(async (templateItemPath) => {
    const outputPath = await create(join(to, relative(from, templateItemPath)))(data);
    if (await isDirectory(templateItemPath)) {
      await mkdir(outputPath);
    } else if (templateItemPath.endsWith(".liquid")) {
      await mkdir(dirname(outputPath));
      const content2 = await read$1(templateItemPath);
      const contentOutput = await create(content2)(data);
      const isExecutable = await hasExecutablePermissions(templateItemPath);
      const outputPathWithoutLiquid = outputPath.replace(".liquid", "");
      await copy(templateItemPath, outputPathWithoutLiquid);
      await write$1(outputPathWithoutLiquid, contentOutput);
      if (isExecutable) {
        await chmod(outputPathWithoutLiquid, 493);
      }
    } else {
      await copy(templateItemPath, outputPath);
    }
  }));
}

var template = /*#__PURE__*/Object.freeze({
  __proto__: null,
  create: create,
  recursiveDirectoryCopy: recursiveDirectoryCopy
});

async function directory(callback) {
  const result = await tempy.directory.task(callback, {});
  return result;
}

var temporary = /*#__PURE__*/Object.freeze({
  __proto__: null,
  directory: directory
});

function decode$1(input) {
  return toml$1.parse(input);
}
function encode$1(content) {
  return toml$1.stringify(content);
}

var toml = /*#__PURE__*/Object.freeze({
  __proto__: null,
  decode: decode$1,
  encode: encode$1
});

const isVSCode = async (root = process.cwd()) => {
  debug$2(content`Checking if the directory ${token.path(root)} or any of its parents has a .vscode directory... `);
  const config = await findUp(join(root, ".vscode"), { type: "directory" });
  if (!config) {
    return false;
  }
  return exists(config);
};
async function addRecommendedExtensions(directory, recommendations) {
  debug$2(content`Adding VSCode recommended extensions at ${token.path(directory)}:
${token.json(recommendations)}
  `);
  const extensionsPath = join(directory, ".vscode/extensions.json");
  if (await isVSCode(directory)) {
    let originalExtensionsJson = { recommendations: [] };
    if (await exists(extensionsPath)) {
      const originalExtensionsFile = await read$1(extensionsPath);
      originalExtensionsJson = JSON.parse(originalExtensionsFile);
    }
    const newExtensionsJson = {
      ...originalExtensionsJson,
      recommendations: [...originalExtensionsJson.recommendations, ...recommendations]
    };
    await write$1(extensionsPath, JSON.stringify(newExtensionsJson, null, 2));
  }
}

var vscode = /*#__PURE__*/Object.freeze({
  __proto__: null,
  isVSCode: isVSCode,
  addRecommendedExtensions: addRecommendedExtensions
});

function decode(input) {
  return yaml$1.load(input);
}
function encode(content) {
  return yaml$1.dump(content);
}

var yaml = /*#__PURE__*/Object.freeze({
  __proto__: null,
  decode: decode,
  encode: encode
});

export { abort, analytics, api, checksum, cli, dependency, dotEnv as dotenv, environment, git, github, haiku, http, id, npm, plugins, port, ruby, schema, semver, session, store$2 as store, string, template, temporary, toml, ui, version, vscode, yaml };
//# sourceMappingURL=index.js.map
