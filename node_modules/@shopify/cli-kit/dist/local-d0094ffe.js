import commondir from 'commondir';
import { relative, dirname, join, normalize, resolve, basename, extname, isAbsolute, sep } from 'pathe';
import { fileURLToPath } from 'url';
import { findUp } from 'find-up';
import glob from 'fast-glob';
import { pathToFileURL } from 'node:url';
import envPaths from 'env-paths';
import { Errors } from '@oclif/core';
import sourceMapSupport from 'source-map-support';
import { ExtendableError } from 'ts-error';
import { AbortSignal, AbortController } from 'abort-controller';
import fs from 'fs-extra';
import del from 'del';
import tempy from 'tempy';
import prettier from 'prettier';
import isInteractive from 'is-interactive';
import { arch, userInfo, homedir } from 'node:os';
import terminalLink from 'terminal-link';
import StackTracey from 'stacktracey';
import cjs from 'color-json';
import { Writable } from 'node:stream';
import { execa } from 'execa';
import { platform } from 'node:process';

function relativize(path) {
  const result = commondir([path, process.cwd()]);
  const relativePath = relative(process.cwd(), path);
  const relativeComponents = relativePath.split("/").filter((component) => component === "..").length;
  if (result === "/" || relativeComponents > 2) {
    return path;
  } else {
    return relativePath;
  }
}
function moduleDirectory(moduleURL) {
  return dirname(fileURLToPath(moduleURL));
}

var path = /*#__PURE__*/Object.freeze({
  __proto__: null,
  join: join,
  relative: relative,
  dirname: dirname,
  normalize: normalize,
  resolve: resolve,
  basename: basename,
  extname: extname,
  isAbsolute: isAbsolute,
  relativize: relativize,
  moduleDirectory: moduleDirectory,
  findUp: findUp,
  glob: glob,
  pathToFileURL: pathToFileURL
});

var name = "@shopify/cli-kit";
var version = "3.0.25";
var description = "A set of utilities, interfaces, and models that are common across all the platform features";
var keywords = [
	"shopify",
	"shopify-cli",
	"shopify-partners"
];
var license = "MIT";
var type = "module";
var module = "dist/index.js";
var types = "dist/index.d.ts";
var exports = {
	".": {
		"import": "./dist/index.js",
		types: "./dist/index.d.ts"
	},
	"./node/*": {
		node: "./dist/node/*.js",
		types: "./dist/node/*.d.ts"
	}
};
var files = [
	"/dist",
	"/assets"
];
var publishConfig = {
	access: "public",
	"@shopify:registry": "https://registry.npmjs.org"
};
var scripts = {
	clean: "shx rm -rf dist",
	build: "rimraf dist/ && rollup -c",
	prepack: "cross-env NODE_ENV=production yarn run build",
	lint: "prettier -c src/** && eslint \"src/**/*.ts\"",
	"lint:fix": "eslint 'src/**/*.ts' --fix",
	test: "vitest run",
	"test:watch": "vitest watch",
	tsc: "tsc --noEmit"
};
var eslintConfig = {
	"extends": [
		"../../.eslintrc.cjs"
	]
};
var engines = {
	node: "^14.13.1 || ^16.0.0 || ^17.0.0 || ^18.0.0"
};
var os$1 = [
	"darwin",
	"linux",
	"win32"
];
var dependencies = {
	"@oclif/core": "^1.0",
	envfile: "^6.17.0",
	fastify: "^4.0.0-rc.4",
	inquirer: "^8.2.4",
	keytar: "^7.9.0",
	open: "^8.4.0",
	prettier: "^2.6.2",
	"source-map-support": "^0.5.21",
	stacktracey: "^2.1.8",
	pathe: "0.2.0",
	"abort-controller": "^3.0.0",
	"ts-error": "^1.0.6",
	"find-up": "^6.2.0",
	execa: "^6.0.0",
	listr2: "^4.0.5",
	"@iarna/toml": "^2.2.5",
	"change-case": "^4.1.2",
	"color-json": "^2.0.1",
	commondir: "^1.0.1",
	conf: "^10.1.2",
	"cross-zip": "^4.0.0",
	del: "^6.0.0",
	enquirer: "^2.3.6",
	"env-paths": "^3.0.0",
	"fast-glob": "^3.2.11",
	"find-versions": "^5.0.0",
	"form-data": "^4.0.0",
	"fs-extra": "^10.0.0",
	"get-port-please": "^2.5.0",
	graphql: "^16.4.0",
	"graphql-request": "^4.3.0",
	haikunator: "^2.1.2",
	"is-interactive": "^2.0.0",
	"js-yaml": "^4.1.0",
	"latest-version": "^6.0.0",
	liquidjs: "^9.36.0",
	"md5-file": "^5.0.0",
	"node-fetch": "^3.2.4",
	"simple-git": "^3.5.0",
	tempy: "^2.0.0",
	"term-size": "^3.0.1",
	"terminal-link": "^3.0.0",
	zod: "^3.17.3"
};
var devDependencies = {
	"@types/cross-zip": "^4.0.0",
	"@types/inquirer": "^8.2.1",
	"@types/js-yaml": "^4.0.5",
	"@types/semver": "^7.3.9",
	vitest: "^0.15.1",
	semver: "^7.3.6",
	"ansi-colors": "^4.1.1"
};
var cliKitPackageJson = {
	name: name,
	version: version,
	"private": false,
	description: description,
	keywords: keywords,
	license: license,
	type: type,
	module: module,
	types: types,
	exports: exports,
	files: files,
	publishConfig: publishConfig,
	scripts: scripts,
	eslintConfig: eslintConfig,
	"engine-strict": true,
	engines: engines,
	os: os$1,
	dependencies: dependencies,
	devDependencies: devDependencies
};

const identifier = "shopify-cli";
const cacheFolder = () => {
  if (process.env.XDG_CACHE_HOME)
    return process.env.XDG_CACHE_HOME;
  return envPaths(identifier).cache;
};
const constants = {
  environmentVariables: {
    unitTest: "SHOPIFY_UNIT_TEST",
    shopifyConfig: "SHOPIFY_CONFIG",
    runAsUser: "SHOPIFY_RUN_AS_USER",
    partnersEnv: "SHOPIFY_PARTNERS_ENV",
    shopifyEnv: "SHOPIFY_SHOPIFY_ENV",
    identityEnv: "SHOPIFY_IDENTITY_ENV",
    spin: "SPIN",
    spinInstance: "SPIN_INSTANCE",
    spinWorkspace: "SPIN_WORKSPACE",
    spinNamespace: "SPIN_NAMESPACE",
    spinHost: "SPIN_HOST",
    partnersToken: "SHOPIFY_CLI_PARTNERS_TOKEN",
    verbose: "SHOPIFY_FLAG_VERBOSE",
    noAnalytics: "SHOPIFY_CLI_NO_ANALYTICS"
  },
  paths: {
    executables: {
      dev: "/opt/dev/bin/dev"
    },
    directories: {
      cache: {
        path: () => {
          return cacheFolder();
        },
        vendor: {
          path: () => {
            return join(cacheFolder(), "vendor");
          },
          binaries: () => {
            return join(cacheFolder(), "vendor", "binaries");
          }
        }
      }
    }
  },
  versions: {
    cliKit: version
  },
  keychain: {
    service: "shopify-cli"
  },
  session: {
    expirationTimeMarginInMinutes: 4
  }
};

function isTruthy(variable) {
  if (!variable) {
    return false;
  }
  return ["1", "true", "TRUE", "yes", "YES"].includes(variable);
}

var utilities = /*#__PURE__*/Object.freeze({
  __proto__: null,
  isTruthy: isTruthy
});

sourceMapSupport.install();
class CancelExecution extends Error {
}
class Fatal extends Error {
  constructor(message, type, tryMessage = null) {
    super(stringifyMessage(message));
    this.tryMessage = tryMessage ? stringifyMessage(tryMessage) : null;
    this.type = type;
  }
}
class Abort extends Fatal {
  constructor(message, tryMessage = null) {
    super(message, 0 /* Abort */, tryMessage);
  }
}
class AbortSilent extends Fatal {
  constructor() {
    super("", 1 /* AbortSilent */);
  }
}
class Bug extends Fatal {
  constructor(message, tryMessage = null) {
    super(message, 2 /* Bug */, tryMessage);
  }
}
async function handler(error$1) {
  let fatal;
  if (isFatal(error$1)) {
    fatal = error$1;
  } else {
    fatal = new Bug(error$1.message);
  }
  if (fatal.type === 2 /* Bug */) {
    fatal.stack = error$1.stack;
  }
  await error(fatal);
  return Promise.resolve(error$1);
}
function mapper(error) {
  if (error instanceof Errors.CLIError) {
    const mappedError = new Abort(error.message);
    mappedError.stack = error.stack;
    return Promise.resolve(mappedError);
  } else {
    return Promise.resolve(error);
  }
}
function isFatal(error) {
  return Object.prototype.hasOwnProperty.call(error, "type");
}
function shouldReport(error) {
  if (!isFatal(error)) {
    return true;
  }
  if (error.type === 2 /* Bug */) {
    return true;
  }
  return false;
}

var error$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  CancelExecution: CancelExecution,
  Fatal: Fatal,
  Abort: Abort,
  AbortSilent: AbortSilent,
  Bug: Bug,
  handler: handler,
  mapper: mapper,
  isFatal: isFatal,
  shouldReport: shouldReport,
  ExtendableError: ExtendableError,
  AbortSignal: AbortSignal
});

const DEFAULT_PRETTIER_CONFIG = {
  arrowParens: "always",
  singleQuote: true,
  bracketSpacing: false,
  trailingComma: "all"
};
function stripUp(path, strip) {
  const parts = path.split(sep);
  return join(...parts.slice(strip));
}
async function inTemporaryDirectory(callback) {
  return tempy.directory.task(callback);
}
async function read(path, options = { encoding: "utf-8" }) {
  debug(content`Reading the content of file at ${token.path(path)}...`);
  const content$1 = await fs.readFile(path, options);
  return content$1;
}
function readSync(path, options = { encoding: "utf-8" }) {
  debug(content`Sync-reading the content of file at ${token.path(path)}...`);
  const content$1 = fs.readFileSync(path, options);
  return content$1.toString();
}
async function copy(from, to) {
  debug(content`Copying file from ${token.path(from)} to ${token.path(to)}...`);
  await fs.copy(from, to);
}
async function touch(path) {
  debug(content`Creating an empty file at ${token.path(path)}...`);
  await fs.ensureFile(path);
}
async function touchSync(path) {
  debug(content`Creating an empty file at ${token.path(path)}...`);
  await fs.ensureFileSync(path);
}
async function write(path, data) {
  debug(content`Writing some content to file at ${token.path(path)}...`);
  await fs.writeFile(path, data);
}
function writeSync(path, data) {
  debug(content`File-writing some content to file at ${token.path(path)}...`);
  fs.writeFileSync(path, data);
}
async function append(path, data) {
  await fs.appendFile(path, data);
}
async function mkdir(path) {
  debug(content`Creating directory at ${token.path(path)}...`);
  await fs.mkdirp(path);
}
function mkdirSync(path) {
  debug(content`Sync-reating directory at ${token.path(path)}...`);
  fs.mkdirpSync(path);
}
async function remove(path) {
  debug(content`Removing file at ${token.path(path)}...`);
  await fs.remove(path);
}
async function rmdir(path, { force } = {}) {
  debug(content`Removing directory at ${token.path(path)}...`);
  await del(path, { force });
}
async function mkTmpDir() {
  debug(content`Creating a temporary directory...`);
  const directory = await fs.mkdtemp("tmp-");
  return directory;
}
async function isDirectory(path) {
  debug(content`Checking if ${token.path(path)} is a directory...`);
  return (await fs.promises.lstat(path)).isDirectory();
}
async function size(path) {
  debug(content`Getting the size of file file at ${token.path(path)}...`);
  return (await fs.stat(path)).size;
}
function sizeSync(path) {
  debug(content`Sync-getting the size of file file at ${token.path(path)}...`);
  return fs.statSync(path).size;
}
async function move(src, dest, options = {}) {
  await fs.move(src, dest, options);
}
async function chmod(path, mode) {
  await fs.promises.chmod(path, mode);
}
async function hasExecutablePermissions(path) {
  try {
    await fs.promises.access(path, fs.constants.X_OK);
    return true;
  } catch {
    return false;
  }
}
async function exists(path) {
  try {
    await fs.promises.access(path);
    return true;
  } catch {
    return false;
  }
}
async function format(content, options) {
  const ext = extname(options.path);
  const prettierConfig = {
    ...DEFAULT_PRETTIER_CONFIG,
    parser: "babel"
  };
  switch (ext) {
    case ".html":
    case ".css":
      prettierConfig.parser = ext.slice(1);
      break;
  }
  const formattedContent = await prettier.format(content, prettierConfig);
  return formattedContent;
}

var file = /*#__PURE__*/Object.freeze({
  __proto__: null,
  stripUp: stripUp,
  inTemporaryDirectory: inTemporaryDirectory,
  read: read,
  readSync: readSync,
  copy: copy,
  touch: touch,
  touchSync: touchSync,
  write: write,
  writeSync: writeSync,
  append: append,
  mkdir: mkdir,
  mkdirSync: mkdirSync,
  remove: remove,
  rmdir: rmdir,
  mkTmpDir: mkTmpDir,
  isDirectory: isDirectory,
  size: size,
  sizeSync: sizeSync,
  move: move,
  chmod: chmod,
  hasExecutablePermissions: hasExecutablePermissions,
  exists: exists,
  format: format
});

var ansiColors = {exports: {}};

var symbols = {exports: {}};

var hasRequiredSymbols;

function requireSymbols () {
	if (hasRequiredSymbols) return symbols.exports;
	hasRequiredSymbols = 1;
	(function (module) {

		const isHyper = typeof process !== 'undefined' && process.env.TERM_PROGRAM === 'Hyper';
		const isWindows = typeof process !== 'undefined' && process.platform === 'win32';
		const isLinux = typeof process !== 'undefined' && process.platform === 'linux';

		const common = {
		  ballotDisabled: '☒',
		  ballotOff: '☐',
		  ballotOn: '☑',
		  bullet: '•',
		  bulletWhite: '◦',
		  fullBlock: '█',
		  heart: '❤',
		  identicalTo: '≡',
		  line: '─',
		  mark: '※',
		  middot: '·',
		  minus: '－',
		  multiplication: '×',
		  obelus: '÷',
		  pencilDownRight: '✎',
		  pencilRight: '✏',
		  pencilUpRight: '✐',
		  percent: '%',
		  pilcrow2: '❡',
		  pilcrow: '¶',
		  plusMinus: '±',
		  question: '?',
		  section: '§',
		  starsOff: '☆',
		  starsOn: '★',
		  upDownArrow: '↕'
		};

		const windows = Object.assign({}, common, {
		  check: '√',
		  cross: '×',
		  ellipsisLarge: '...',
		  ellipsis: '...',
		  info: 'i',
		  questionSmall: '?',
		  pointer: '>',
		  pointerSmall: '»',
		  radioOff: '( )',
		  radioOn: '(*)',
		  warning: '‼'
		});

		const other = Object.assign({}, common, {
		  ballotCross: '✘',
		  check: '✔',
		  cross: '✖',
		  ellipsisLarge: '⋯',
		  ellipsis: '…',
		  info: 'ℹ',
		  questionFull: '？',
		  questionSmall: '﹖',
		  pointer: isLinux ? '▸' : '❯',
		  pointerSmall: isLinux ? '‣' : '›',
		  radioOff: '◯',
		  radioOn: '◉',
		  warning: '⚠'
		});

		module.exports = (isWindows && !isHyper) ? windows : other;
		Reflect.defineProperty(module.exports, 'common', { enumerable: false, value: common });
		Reflect.defineProperty(module.exports, 'windows', { enumerable: false, value: windows });
		Reflect.defineProperty(module.exports, 'other', { enumerable: false, value: other });
} (symbols));
	return symbols.exports;
}

const isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);

/* eslint-disable no-control-regex */
// this is a modified version of https://github.com/chalk/ansi-regex (MIT License)
const ANSI_REGEX = /[\u001b\u009b][[\]#;?()]*(?:(?:(?:[^\W_]*;?[^\W_]*)\u0007)|(?:(?:[0-9]{1,4}(;[0-9]{0,4})*)?[~0-9=<>cf-nqrtyA-PRZ]))/g;

const hasColor = () => {
  if (typeof process !== 'undefined') {
    return process.env.FORCE_COLOR !== '0';
  }
  return false;
};

const create = () => {
  const colors = {
    enabled: hasColor(),
    visible: true,
    styles: {},
    keys: {}
  };

  const ansi = style => {
    let open = style.open = `\u001b[${style.codes[0]}m`;
    let close = style.close = `\u001b[${style.codes[1]}m`;
    let regex = style.regex = new RegExp(`\\u001b\\[${style.codes[1]}m`, 'g');
    style.wrap = (input, newline) => {
      if (input.includes(close)) input = input.replace(regex, close + open);
      let output = open + input + close;
      // see https://github.com/chalk/chalk/pull/92, thanks to the
      // chalk contributors for this fix. However, we've confirmed that
      // this issue is also present in Windows terminals
      return newline ? output.replace(/\r*\n/g, `${close}$&${open}`) : output;
    };
    return style;
  };

  const wrap = (style, input, newline) => {
    return typeof style === 'function' ? style(input) : style.wrap(input, newline);
  };

  const style = (input, stack) => {
    if (input === '' || input == null) return '';
    if (colors.enabled === false) return input;
    if (colors.visible === false) return '';
    let str = '' + input;
    let nl = str.includes('\n');
    let n = stack.length;
    if (n > 0 && stack.includes('unstyle')) {
      stack = [...new Set(['unstyle', ...stack])].reverse();
    }
    while (n-- > 0) str = wrap(colors.styles[stack[n]], str, nl);
    return str;
  };

  const define = (name, codes, type) => {
    colors.styles[name] = ansi({ name, codes });
    let keys = colors.keys[type] || (colors.keys[type] = []);
    keys.push(name);

    Reflect.defineProperty(colors, name, {
      configurable: true,
      enumerable: true,
      set(value) {
        colors.alias(name, value);
      },
      get() {
        let color = input => style(input, color.stack);
        Reflect.setPrototypeOf(color, colors);
        color.stack = this.stack ? this.stack.concat(name) : [name];
        return color;
      }
    });
  };

  define('reset', [0, 0], 'modifier');
  define('bold', [1, 22], 'modifier');
  define('dim', [2, 22], 'modifier');
  define('italic', [3, 23], 'modifier');
  define('underline', [4, 24], 'modifier');
  define('inverse', [7, 27], 'modifier');
  define('hidden', [8, 28], 'modifier');
  define('strikethrough', [9, 29], 'modifier');

  define('black', [30, 39], 'color');
  define('red', [31, 39], 'color');
  define('green', [32, 39], 'color');
  define('yellow', [33, 39], 'color');
  define('blue', [34, 39], 'color');
  define('magenta', [35, 39], 'color');
  define('cyan', [36, 39], 'color');
  define('white', [37, 39], 'color');
  define('gray', [90, 39], 'color');
  define('grey', [90, 39], 'color');

  define('bgBlack', [40, 49], 'bg');
  define('bgRed', [41, 49], 'bg');
  define('bgGreen', [42, 49], 'bg');
  define('bgYellow', [43, 49], 'bg');
  define('bgBlue', [44, 49], 'bg');
  define('bgMagenta', [45, 49], 'bg');
  define('bgCyan', [46, 49], 'bg');
  define('bgWhite', [47, 49], 'bg');

  define('blackBright', [90, 39], 'bright');
  define('redBright', [91, 39], 'bright');
  define('greenBright', [92, 39], 'bright');
  define('yellowBright', [93, 39], 'bright');
  define('blueBright', [94, 39], 'bright');
  define('magentaBright', [95, 39], 'bright');
  define('cyanBright', [96, 39], 'bright');
  define('whiteBright', [97, 39], 'bright');

  define('bgBlackBright', [100, 49], 'bgBright');
  define('bgRedBright', [101, 49], 'bgBright');
  define('bgGreenBright', [102, 49], 'bgBright');
  define('bgYellowBright', [103, 49], 'bgBright');
  define('bgBlueBright', [104, 49], 'bgBright');
  define('bgMagentaBright', [105, 49], 'bgBright');
  define('bgCyanBright', [106, 49], 'bgBright');
  define('bgWhiteBright', [107, 49], 'bgBright');

  colors.ansiRegex = ANSI_REGEX;
  colors.hasColor = colors.hasAnsi = str => {
    colors.ansiRegex.lastIndex = 0;
    return typeof str === 'string' && str !== '' && colors.ansiRegex.test(str);
  };

  colors.alias = (name, color) => {
    let fn = typeof color === 'string' ? colors[color] : color;

    if (typeof fn !== 'function') {
      throw new TypeError('Expected alias to be the name of an existing color (string) or a function');
    }

    if (!fn.stack) {
      Reflect.defineProperty(fn, 'name', { value: name });
      colors.styles[name] = fn;
      fn.stack = [name];
    }

    Reflect.defineProperty(colors, name, {
      configurable: true,
      enumerable: true,
      set(value) {
        colors.alias(name, value);
      },
      get() {
        let color = input => style(input, color.stack);
        Reflect.setPrototypeOf(color, colors);
        color.stack = this.stack ? this.stack.concat(fn.stack) : fn.stack;
        return color;
      }
    });
  };

  colors.theme = custom => {
    if (!isObject(custom)) throw new TypeError('Expected theme to be an object');
    for (let name of Object.keys(custom)) {
      colors.alias(name, custom[name]);
    }
    return colors;
  };

  colors.alias('unstyle', str => {
    if (typeof str === 'string' && str !== '') {
      colors.ansiRegex.lastIndex = 0;
      return str.replace(colors.ansiRegex, '');
    }
    return '';
  });

  colors.alias('noop', str => str);
  colors.none = colors.clear = colors.noop;

  colors.stripColor = colors.unstyle;
  colors.symbols = requireSymbols();
  colors.define = define;
  return colors;
};

ansiColors.exports = create();
ansiColors.exports.create = create;

let logFile;
function initiateLogging({
  logDir = constants.paths.directories.cache.path(),
  filename = "shopify.log"
}) {
  mkdirSync(logDir);
  logFile = join(logDir, filename);
  touchSync(logFile);
  truncateLogs();
}
function truncateLogs() {
  try {
    if (sizeSync(logFile) > 5 * 1024 * 1024) {
      const contents = readSync(logFile);
      const splitContents = contents.split("\n");
      const newContents = splitContents.slice(1e4, splitContents.length).join("\n");
      writeSync(logFile, newContents);
    }
  } catch {
  }
}
class ContentToken {
  constructor(value, metadata = {}, type) {
    this.type = type;
    this.value = value;
    this.metadata = metadata;
  }
}
const token = {
  raw: (value) => {
    return new ContentToken(value, {}, 0 /* Raw */);
  },
  genericShellCommand: (value) => {
    return new ContentToken(value, {}, 1 /* Command */);
  },
  json: (value) => {
    return new ContentToken(value, {}, 2 /* Json */);
  },
  path: (value) => {
    return new ContentToken(value, {}, 3 /* Path */);
  },
  link: (value, link) => {
    return new ContentToken(value, { link }, 4 /* Link */);
  },
  heading: (value) => {
    return new ContentToken(value, {}, 5 /* Heading */);
  },
  subheading: (value) => {
    return new ContentToken(value, {}, 6 /* SubHeading */);
  },
  italic: (value) => {
    return new ContentToken(value, {}, 7 /* Italic */);
  },
  errorText: (value) => {
    return new ContentToken(value, {}, 8 /* ErrorText */);
  },
  cyan: (value) => {
    return new ContentToken(value, {}, 10 /* Cyan */);
  },
  yellow: (value) => {
    return new ContentToken(value, {}, 9 /* Yellow */);
  },
  magenta: (value) => {
    return new ContentToken(value, {}, 11 /* Magenta */);
  },
  green: (value) => {
    return new ContentToken(value, {}, 12 /* Green */);
  },
  packagejsonScript: (dependencyManager, scriptName, ...scriptArgs) => {
    return new ContentToken(formatPackageManagerCommand(dependencyManager, scriptName, scriptArgs), {}, 1 /* Command */);
  },
  successIcon: () => {
    return new ContentToken("\u2714", {}, 12 /* Green */);
  },
  failIcon: () => {
    return new ContentToken("\u2716", {}, 8 /* ErrorText */);
  }
};
function formatPackageManagerCommand(dependencyManager, scriptName, scriptArgs) {
  switch (dependencyManager) {
    case "yarn": {
      const pieces = ["yarn", scriptName, ...scriptArgs];
      return pieces.join(" ");
    }
    case "pnpm":
    case "npm": {
      const pieces = [dependencyManager, "run", scriptName];
      if (scriptArgs.length > 0) {
        pieces.push("--");
        pieces.push(...scriptArgs);
      }
      return pieces.join(" ");
    }
  }
}
class TokenizedString {
  constructor(value) {
    this.value = value;
  }
}
function content(strings, ...keys) {
  let output = ``;
  strings.forEach((string, i) => {
    output += string;
    if (i >= keys.length) {
      return;
    }
    const token2 = keys[i];
    if (typeof token2 === "string") {
      output += token2;
    } else {
      const enumToken = token2;
      switch (enumToken.type) {
        case 0 /* Raw */:
          output += enumToken.value;
          break;
        case 1 /* Command */:
          output += ansiColors.exports.bold(ansiColors.exports.yellow(stringifyMessage(enumToken.value)));
          break;
        case 3 /* Path */:
          output += relativize(stringifyMessage(enumToken.value));
          break;
        case 2 /* Json */:
          try {
            output += cjs(stringifyMessage(enumToken.value) ?? {});
          } catch (_) {
            output += JSON.stringify(stringifyMessage(enumToken.value) ?? {}, null, 2);
          }
          break;
        case 4 /* Link */:
          output += terminalLink(ansiColors.exports.green(stringifyMessage(enumToken.value)), enumToken.metadata.link ?? "");
          break;
        case 5 /* Heading */:
          output += ansiColors.exports.bold.underline(stringifyMessage(enumToken.value));
          break;
        case 6 /* SubHeading */:
          output += ansiColors.exports.underline(stringifyMessage(enumToken.value));
          break;
        case 7 /* Italic */:
          output += ansiColors.exports.italic(stringifyMessage(enumToken.value));
          break;
        case 8 /* ErrorText */:
          output += ansiColors.exports.bold.redBright(stringifyMessage(enumToken.value));
          break;
        case 9 /* Yellow */:
          output += ansiColors.exports.yellow(stringifyMessage(enumToken.value));
          break;
        case 10 /* Cyan */:
          output += ansiColors.exports.cyan(stringifyMessage(enumToken.value));
          break;
        case 11 /* Magenta */:
          output += ansiColors.exports.magenta(stringifyMessage(enumToken.value));
          break;
        case 12 /* Green */:
          output += ansiColors.exports.green(stringifyMessage(enumToken.value));
          break;
      }
    }
  });
  return new TokenizedString(output);
}
const logLevelValue = (level) => {
  switch (level) {
    case "trace":
      return 10;
    case "debug":
      return 20;
    case "info":
      return 30;
    case "warn":
      return 40;
    case "error":
      return 50;
    case "fatal":
      return 60;
    default:
      return 30;
  }
};
const currentLogLevel = () => {
  if (isVerbose()) {
    return "debug";
  } else {
    return "info";
  }
};
const shouldOutput = (logLevel) => {
  if (isUnitTest()) {
    return false;
  }
  const currentLogLevelValue = logLevelValue(currentLogLevel());
  const messageLogLevelValue = logLevelValue(logLevel);
  return messageLogLevelValue >= currentLogLevelValue;
};
const info = (content2) => {
  message(content2, "info");
};
const success = (content2) => {
  const message2 = ansiColors.exports.bold(`\u2705 Success! ${stringifyMessage(content2)}.`);
  outputWhereAppropriate("info", consoleLog, message2);
};
const completed = (content2) => {
  const message2 = `${ansiColors.exports.green("\u2714")} ${stringifyMessage(content2)}`;
  outputWhereAppropriate("info", consoleLog, message2);
};
const debug = (content2) => {
  message(ansiColors.exports.gray(stringifyMessage(content2)), "debug");
};
const warn = (content2) => {
  consoleWarn(ansiColors.exports.yellow(stringifyMessage(content2)));
};
const newline = () => {
  console.log();
};
const error = async (content2) => {
  if (!content2.message) {
    return;
  }
  let outputString = "";
  const message2 = content2.message;
  const padding = "    ";
  const header = ansiColors.exports.redBright(`
\u2501\u2501\u2501\u2501\u2501\u2501 Error \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501
`);
  const footer = ansiColors.exports.redBright("\n\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\n");
  outputString += header;
  const lines = message2.split("\n");
  for (const line of lines) {
    outputString += `${padding}${line}
`;
  }
  if (content2.tryMessage) {
    outputString += `
${padding}${ansiColors.exports.bold("What to try:")}
`;
    const lines2 = content2.tryMessage.split("\n");
    for (const line of lines2) {
      outputString += `${padding}${line}
`;
    }
  }
  let stack = await new StackTracey(content2).withSourcesAsync();
  stack = stack.filter((entry) => {
    return !entry.file.includes("@oclif/core");
  }).map((item) => {
    item.calleeShort = ansiColors.exports.yellow(item.calleeShort);
    const fileShortComponents = item.fileShort.split("packages/");
    item.fileShort = fileShortComponents.length === 2 ? fileShortComponents[1] : fileShortComponents[0];
    return item;
  });
  if (content2 instanceof Bug) {
    if (stack.items.length !== 0) {
      outputString += `
${padding}${ansiColors.exports.bold("Stack trace:")}`;
      const stackLines = stack.asTable({}).split("\n");
      for (const stackLine of stackLines) {
        outputString += `${padding}${stackLine}
`;
      }
    }
  }
  outputString += footer;
  outputWhereAppropriate("error", consoleError, outputString);
};
function stringifyMessage(message2) {
  if (message2 instanceof TokenizedString) {
    return message2.value;
  } else {
    return message2;
  }
}
const message = (content2, level = "info") => {
  const stringifiedMessage = stringifyMessage(content2);
  outputWhereAppropriate(level, consoleLog, stringifiedMessage);
};
async function concurrent(processes, callback = void 0) {
  const abortController = new AbortController();
  if (callback)
    callback(abortController.signal);
  const concurrentColors = [token.yellow, token.cyan, token.magenta, token.green];
  const prefixColumnSize = Math.max(...processes.map((process2) => process2.prefix.length));
  function linePrefix(prefix, index) {
    const colorIndex = index < concurrentColors.length ? index : index % concurrentColors.length;
    const color = concurrentColors[colorIndex];
    return color(`${prefix}${" ".repeat(prefixColumnSize - prefix.length)} ${ansiColors.exports.bold("|")} `);
  }
  try {
    await Promise.all(processes.map(async (process2, index) => {
      const stdout = new Writable({
        write(chunk, _encoding, next) {
          const lines = stripAnsiEraseCursorEscapeCharacters(chunk.toString("ascii")).split(/\n/);
          for (const line of lines) {
            info(content`${linePrefix(process2.prefix, index)}${line}`);
          }
          next();
        }
      });
      const stderr = new Writable({
        write(chunk, _encoding, next) {
          const lines = stripAnsiEraseCursorEscapeCharacters(chunk.toString("ascii")).split(/\n/);
          for (const line of lines) {
            message(content`${linePrefix(process2.prefix, index)}${ansiColors.exports.bold(line)}`, "error");
          }
          next();
        }
      });
      await process2.action(stdout, stderr, abortController.signal);
    }));
  } catch (_error) {
    abortController.abort();
    throw _error;
  }
}
const eraseCursorAnsiRegex = [
  "2K",
  "1G"
].map((element) => `[\\u001B\\u009B][[\\]()#;?]*${element}`).join("|");
function stripAnsiEraseCursorEscapeCharacters(value) {
  return value.replace(/(\n)$/, "").replace(new RegExp(eraseCursorAnsiRegex, "g"), "");
}
function consoleLog(message2) {
  console.log(withOrWithoutStyle(message2));
}
function consoleError(message2) {
  console.error(withOrWithoutStyle(message2));
}
function consoleWarn(message2) {
  console.warn(withOrWithoutStyle(message2));
}
function outputWhereAppropriate(logLevel, logFunc, message2) {
  if (shouldOutput(logLevel)) {
    logFunc(message2);
  }
  logToFile(message2, logLevel.toUpperCase());
}
function logFileExists() {
  return Boolean(logFile);
}
function logToFile(message2, logLevel) {
  if (!logFileExists())
    return;
  const timestamp = new Date().toISOString();
  append(logFile, `[${timestamp} ${logLevel}]: ${message2}
`);
}
function withOrWithoutStyle(message2) {
  if (shouldDisplayColors()) {
    return message2;
  } else {
    return unstyled(message2);
  }
}
function unstyled(message2) {
  return ansiColors.exports.unstyle(message2);
}
function shouldDisplayColors() {
  return Boolean(process.stdout.isTTY || process.env.FORCE_COLOR);
}
async function pageLogs() {
  await page(logFile);
}

var output = /*#__PURE__*/Object.freeze({
  __proto__: null,
  initiateLogging: initiateLogging,
  token: token,
  TokenizedString: TokenizedString,
  content: content,
  currentLogLevel: currentLogLevel,
  shouldOutput: shouldOutput,
  info: info,
  success: success,
  completed: completed,
  debug: debug,
  warn: warn,
  newline: newline,
  error: error,
  stringifyMessage: stringifyMessage,
  concurrent: concurrent,
  unstyled: unstyled,
  shouldDisplayColors: shouldDisplayColors,
  pageLogs: pageLogs
});

const getEnvironmentVariable = () => {
  const { env } = process;
  return env.SUDO_USER || env.C9_USER || env.LOGNAME || env.USER || env.LNAME || env.USERNAME;
};
const getUsernameFromOsUserInfo = () => {
  try {
    return userInfo().username;
  } catch {
    return null;
  }
};
const cleanWindowsCommand = (value) => value.replace(/^.*\\/, "");
const makeUsernameFromId = (userId) => `no-username-${userId}`;
const username = async (platform$1 = platform) => {
  debug(content`Obtaining user name...`);
  const environmentVariable = getEnvironmentVariable();
  if (environmentVariable) {
    return environmentVariable;
  }
  const userInfoUsername = getUsernameFromOsUserInfo();
  if (userInfoUsername) {
    return userInfoUsername;
  }
  try {
    if (platform$1 === "win32") {
      const { stdout } = await execa("whoami");
      return cleanWindowsCommand(stdout);
    }
    const { stdout: userId } = await execa("id", ["-u"]);
    try {
      const { stdout } = await execa("id", ["-un", userId]);
      return stdout;
    } catch {
    }
    return makeUsernameFromId(userId);
  } catch {
    return null;
  }
};
const platformAndArch = (platform$1 = platform) => {
  let arch$1 = arch();
  if (arch$1 === "x64") {
    arch$1 = "amd64";
  }
  let platformString = platform$1;
  if (platform$1.match(/^win.+/)) {
    platformString = "windows";
  }
  return { platform: platformString, arch: arch$1 };
};

var os = /*#__PURE__*/Object.freeze({
  __proto__: null,
  username: username,
  platformAndArch: platformAndArch
});

const open = async (url) => {
  const externalOpen = await import('open');
  await externalOpen.default(url);
};
const captureOutput = async (command, args, options) => {
  const result = await buildExec(command, args, options);
  return result.stdout;
};
const exec = async (command, args, options) => {
  const commandProcess = buildExec(command, args, options);
  if (options?.stderr) {
    commandProcess.stderr?.pipe(options.stderr);
  }
  if (options?.stdout && options.stdout !== "inherit") {
    commandProcess.stdout?.pipe(options.stdout);
  }
  options?.signal?.addEventListener("abort", () => {
    commandProcess.kill("SIGTERM", { forceKillAfterTimeout: 1e3 });
  });
  try {
    await commandProcess;
  } catch (processError) {
    const abortError = new Abort(processError.message);
    abortError.stack = processError.stack;
    throw abortError;
  }
};
const buildExec = (command, args, options) => {
  const env = options?.env ?? process.env;
  if (shouldDisplayColors()) {
    env.FORCE_COLOR = "1";
  }
  const commandProcess = execa(command, args, {
    env,
    cwd: options?.cwd,
    input: options?.stdin,
    stdout: options?.stdout === "inherit" ? "inherit" : void 0
  });
  debug(`
Running system process:
  \xB7 Command: ${command} ${args.join(" ")}
  \xB7 Working directory: ${options?.cwd ?? process.cwd()}
`);
  return commandProcess;
};
const concurrentExec = async (commands) => {
  await concurrent(commands.map((command) => {
    return {
      prefix: command.prefix,
      action: async (stdout, stderr, signal) => {
        await exec(command.executable, command.args, {
          stdout,
          stderr,
          cwd: command.cwd,
          signal
        });
      }
    };
  }));
};
async function page(filename) {
  let executable;
  if (process.env.PAGER) {
    executable = process.env.PAGER;
  } else if ((await platformAndArch()).platform === "windows") {
    executable = "more";
  } else {
    executable = "less -NR";
  }
  const [command, ...args] = [...executable.split(" "), filename];
  await exec(command, args, { stdout: "inherit", stdin: "inherit" });
}
async function sleep(seconds) {
  return new Promise((resolve) => {
    setTimeout(resolve, 1e3 * seconds);
  });
}

var system = /*#__PURE__*/Object.freeze({
  __proto__: null,
  open: open,
  captureOutput: captureOutput,
  exec: exec,
  concurrentExec: concurrentExec,
  page: page,
  sleep: sleep
});

const SpinInstanceNotFound = (spinInstance, error) => {
  const errorMessage = content`${token.genericShellCommand(`spin`)} yielded the following error trying to obtain the fully qualified domain name of the Spin instance:
${error}
  `;
  let nextSteps;
  if (spinInstance) {
    nextSteps = `Make sure ${spinInstance} is the instance name and not a fully qualified domain name`;
  }
  return new Abort(errorMessage, nextSteps);
};
async function fqdn(env = process.env) {
  const spinInstance = await instance(env);
  const showResponse = await show(spinInstance, env);
  return showResponse.fqdn;
}
async function show(spinInstance, env = process.env) {
  const latest = spinInstance === void 0;
  const args = latest ? ["show", "--latest", "--json"] : ["show", "--json"];
  const output = await captureOutput("spin", args, { env });
  const json = JSON.parse(output);
  if (json.error) {
    throw SpinInstanceNotFound(spinInstance, json.error);
  } else {
    return json;
  }
}
function isSpin(env = process.env) {
  return isTruthy(env[constants.environmentVariables.spin]);
}
function instance(env = process.env) {
  return env[constants.environmentVariables.spinInstance];
}

function isTerminalInteractive() {
  return isInteractive();
}
function homeDirectory() {
  return homedir();
}
function isDebug(env = process.env) {
  return env[constants.environmentVariables.shopifyConfig] === "debug";
}
function isVerbose(env = process.env) {
  return isTruthy(env[constants.environmentVariables.verbose]) || process.argv.includes("--verbose");
}
async function isShopify(env = process.env) {
  if (Object.prototype.hasOwnProperty.call(env, constants.environmentVariables.runAsUser)) {
    return !isTruthy(env[constants.environmentVariables.runAsUser]);
  }
  const devInstalled = await exists(constants.paths.executables.dev);
  return devInstalled || isSpin();
}
function isUnitTest(env = process.env) {
  return isTruthy(env[constants.environmentVariables.unitTest]);
}
function analyticsDisabled(env = process.env) {
  return isTruthy(env[constants.environmentVariables.noAnalytics]);
}
async function hasGit() {
  try {
    await exec("git", ["--version"]);
    return true;
  } catch {
    return false;
  }
}

var local = /*#__PURE__*/Object.freeze({
  __proto__: null,
  isTerminalInteractive: isTerminalInteractive,
  homeDirectory: homeDirectory,
  isDebug: isDebug,
  isVerbose: isVerbose,
  isShopify: isShopify,
  isUnitTest: isUnitTest,
  analyticsDisabled: analyticsDisabled,
  hasGit: hasGit
});

export { Abort as A, Bug as B, hasGit as C, username as D, moduleDirectory as E, open as F, warn as G, completed as H, isDirectory as I, hasExecutablePermissions as J, copy as K, chmod as L, error$1 as M, file as N, os as O, output as P, path as Q, system as R, ansiColors as a, content as b, constants as c, isTruthy as d, info as e, fqdn as f, exists as g, AbortSilent as h, isTerminalInteractive as i, exec as j, captureOutput as k, local as l, mkdir as m, cliKitPackageJson as n, debug as o, read as p, isDebug as q, remove as r, analyticsDisabled as s, token as t, utilities as u, version as v, write as w, platformAndArch as x, isShopify as y, stringifyMessage as z };
//# sourceMappingURL=local-d0094ffe.js.map
