'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var React = require('react');
var reactDom = require('react-dom');
var testUtils = require('react-dom/test-utils');
var TestWrapper = require('./TestWrapper.js');
var element = require('./element.js');
var compat = require('./compat.js');
var types = require('./types.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var React__default = /*#__PURE__*/_interopDefaultLegacy(React);

const {
  findCurrentFiberUsingSlowPath
} = require('react-reconciler/reflection');

const connected = new Set();
class Root {
  get props() {
    return this.withRoot(root => root.props);
  }

  get isDOM() {
    return this.withRoot(root => root.isDOM);
  }

  get type() {
    return this.withRoot(root => root.type);
  }

  get instance() {
    return this.withRoot(root => root.instance);
  }

  get children() {
    return this.withRoot(root => root.children);
  }

  get descendants() {
    return this.withRoot(root => root.descendants);
  }

  get domNodes() {
    return this.withRoot(root => root.domNodes);
  }

  get domNode() {
    return this.withRoot(root => root.domNode);
  }

  get mounted() {
    return this.wrapper != null;
  }

  constructor(tree, {
    render = defaultRender,
    resolveRoot = defaultResolveRoot
  } = {}) {
    this.tree = tree;
    this.wrapper = null;
    this.element = document.createElement('div');
    this.root = null;
    this.acting = false;
    this.render = void 0;
    this.resolveRoot = void 0;
    this.render = render;
    this.resolveRoot = resolveRoot;
    this.mount();
  }

  act(action, {
    update = true
  } = {}) {
    const updateWrapper = update ? this.update.bind(this) : noop;
    let result;

    if (this.acting) {
      return action();
    }

    this.acting = true;

    const afterResolve = () => {
      updateWrapper();
      this.acting = false;
      return result;
    };

    const promise = testUtils.act(() => {
      result = action(); // This condition checks the returned value is an actual Promise and returns it
      // to Reactâ€™s `act()` call, otherwise we just want to return `undefined`

      if (isPromise(result)) {
        return result;
      }

      return undefined;
    });

    if (isPromise(result)) {
      updateWrapper();
      return Promise.resolve(promise).then(afterResolve);
    }

    return afterResolve();
  }

  html() {
    return this.withRoot(root => root.html());
  }

  text() {
    return this.withRoot(root => root.text());
  }

  is(type) {
    return this.withRoot(root => root.is(type));
  }

  prop(key) {
    return this.withRoot(root => root.prop(key));
  }

  data(key) {
    return this.withRoot(root => root.data(key));
  }

  find(type, props) {
    return this.withRoot(root => root.find(type, props));
  }

  findAll(type, props) {
    return this.withRoot(root => root.findAll(type, props));
  }

  findWhere(predicate) {
    return this.withRoot(root => root.findWhere(predicate));
  }

  findAllWhere(predicate) {
    return this.withRoot(root => root.findAllWhere(predicate));
  }

  trigger(prop, ...args) {
    return this.withRoot(root => root.trigger(prop, ...args));
  }

  triggerKeypath(keypath, ...args) {
    return this.withRoot(root => root.triggerKeypath(keypath, ...args));
  }

  mount() {
    if (this.mounted) {
      throw new Error('Attempted to mount a node that was already mounted');
    }

    if (this.element.parentNode == null) {
      document.body.appendChild(this.element);
      connected.add(this);
    }

    this.act(() => {
      reactDom.render( /*#__PURE__*/React__default["default"].createElement(TestWrapper.TestWrapper, {
        render: this.render,
        ref: wrapper => {
          this.wrapper = wrapper;
        }
      }, this.tree), this.element);
    });
  }

  unmount() {
    if (!this.mounted) {
      throw new Error('You attempted to unmount a node that was already unmounted');
    }

    this.ensureRoot();
    this.act(() => reactDom.unmountComponentAtNode(this.element));
  }

  destroy() {
    const {
      element,
      mounted
    } = this;

    if (mounted) {
      this.unmount();
    }

    element.remove();
    connected.delete(this);
  }

  setProps(props) {
    this.ensureRoot();
    this.act(() => this.wrapper.setProps(props));
  }

  forceUpdate() {
    this.ensureRoot();
    this.act(() => this.wrapper.forceUpdate());
  }

  debug(options) {
    this.ensureRoot();
    return this.root.debug(options);
  }

  toString() {
    return this.withRoot(root => root.toString());
  }

  update() {
    if (this.wrapper == null) {
      this.root = null;
    } else {
      const rootFiber = compat.getInternals(this.wrapper.rootRef);
      const topElement = fiberToElement(findCurrentFiberUsingSlowPath(rootFiber), this);
      this.root = this.resolveRoot(topElement);
    }
  }

  ensureRoot() {
    if (this.wrapper == null || this.root == null) {
      throw new Error('Attempted to operate on a mounted tree, but the component is no longer mounted');
    }
  }

  withRoot(withRoot) {
    this.ensureRoot();
    return withRoot(this.root);
  }

}

function defaultResolveRoot(element) {
  return element.children[0];
}

function defaultRender(element) {
  return element;
}

function fiberToElement(node, root) {
  if (node.tag === types.Tag.HostText) {
    return node.memoizedProps;
  }

  const props = node.memoizedProps;
  const children = childrenToTree(node.child, root);
  return new element.Element({
    tag: node.tag,
    type: node.type,
    props,
    instance: node.stateNode
  }, children, root);
}

function childrenToTree(fiber, root) {
  let currentFiber = fiber;
  const children = [];

  while (currentFiber != null) {
    const result = fiberToElement(currentFiber, root);
    children.push(result);
    currentFiber = currentFiber.sibling;
  }

  return children;
}

function isPromise(promise) {
  return promise != null && typeof promise === 'object' && 'then' in promise;
}

function noop() {}

exports.Root = Root;
exports.connected = connected;
