import { toReactString, nodeName } from './toReactString.mjs';
import { Tag } from './types.mjs';

class Element {
  get props() {
    return this.tree.props;
  }

  get type() {
    return this.tree.type;
  }

  get isDOM() {
    return this.tree.tag === Tag.HostComponent;
  }

  get instance() {
    return this.tree.instance;
  }

  get children() {
    return this.elementChildren;
  }

  get elementDescendants() {
    if (!this.descendantsCache) {
      this.descendantsCache = getDescendants(this);
    }

    return this.descendantsCache;
  }

  get elementChildren() {
    if (!this.elementChildrenCache) {
      this.elementChildrenCache = this.allChildren.filter(element => typeof element !== 'string');
    }

    return this.elementChildrenCache;
  }

  get descendants() {
    return this.elementDescendants;
  }

  get domNodes() {
    if (this.isDOM) {
      return [this.instance];
    }

    return this.elementChildren.filter(element => element.isDOM).map(element => element.instance);
  }

  get domNode() {
    const {
      domNodes
    } = this;

    if (domNodes.length > 1) {
      throw new Error('You canâ€™t call getDOMNode() on an element that returns multiple HTML elements. Call getDOMNodes() to retrieve all of the elements instead.');
    }

    return domNodes[0] || null;
  }

  constructor(tree, allChildren, root) {
    this.tree = tree;
    this.allChildren = allChildren;
    this.root = root;
    this.descendantsCache = null;
    this.elementChildrenCache = null;
  }

  data(key) {
    return this.props[key.startsWith('data-') ? key : `data-${key}`];
  }

  prop(key) {
    return this.props[key];
  }

  text() {
    const {
      instance,
      allChildren,
      tree: {
        tag
      }
    } = this;

    if (tag === Tag.HostPortal) {
      return '';
    }

    if (instance instanceof HTMLElement) {
      return instance.textContent || '';
    }

    return allChildren.reduce((text, child) => text + (typeof child === 'string' ? child : child.text()), '');
  }

  html() {
    const {
      instance,
      allChildren,
      tree: {
        tag
      }
    } = this;

    if (tag === Tag.HostPortal) {
      return '';
    }

    if (instance instanceof HTMLElement) {
      return instance.outerHTML;
    }

    return allChildren.reduce((text, child) => text + (typeof child === 'string' ? child : child.html()), '');
  }

  is(type) {
    return isMatchingType(this.type, type);
  }

  find(type, props) {
    return this.elementDescendants.find(element => isMatchingType(element.type, type) && (props == null || equalSubset(props, element.props))) || null;
  }

  findAll(type, props) {
    return this.elementDescendants.filter(element => isMatchingType(element.type, type) && (props == null || equalSubset(props, element.props)));
  }

  findWhere(predicate) {
    return this.elementDescendants.find(element => predicate(element)) || null;
  }

  findAllWhere(predicate) {
    return this.elementDescendants.filter(element => predicate(element));
  }

  trigger(prop, ...args) {
    return this.root.act(() => {
      const propValue = this.props[prop];

      if (propValue == null) {
        throw new Error(`Attempted to call prop ${prop} but it was not defined.`);
      }

      return propValue(...args);
    });
  }

  triggerKeypath(keypath, ...args) {
    return this.root.act(() => {
      const {
        props
      } = this;
      const parts = keypath.split(/[.[\]]/g).filter(Boolean);
      let currentProp = props;
      const currentKeypath = [];

      for (const part of parts) {
        if (currentProp == null || typeof currentProp !== 'object') {
          throw new Error(`Attempted to access field keypath '${currentKeypath.join('.')}', but it was not an object.`);
        }

        currentProp = currentProp[part];
        currentKeypath.push(part);
      }

      if (typeof currentProp !== 'function') {
        throw new Error(`Value at keypath '${keypath}' is not a function.`);
      }

      return currentProp(...args);
    });
  }

  debug(options) {
    return toReactString(this, options);
  }

  toString() {
    return `<${nodeName(this)} />`;
  }

}

function isMatchingType(type, test) {
  if (type === test) {
    return true;
  }

  if (test == null) {
    return false;
  }

  return test.type != null && isMatchingType(type, test.type);
}

function equalSubset(subset, full) {
  return Object.keys(subset).every(key => key in full && full[key] === subset[key]);
}

function getDescendants(element) {
  const descendants = []; // eslint-disable-next-line @typescript-eslint/prefer-for-of

  for (let i = 0; i < element.allChildren.length; i++) {
    const child = element.allChildren[i];

    if (typeof child !== 'string') {
      descendants.push(child); // eslint-disable-next-line prefer-spread

      descendants.push.apply(descendants, child.elementDescendants);
    }
  }

  return descendants;
}

export { Element };
